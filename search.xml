<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java SE基础</title>
      <link href="/2023/07/16/java-se-ji-chu/"/>
      <url>/2023/07/16/java-se-ji-chu/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-SE基础"><a href="#Java-SE基础" class="headerlink" title="Java SE基础"></a>Java SE基础</h1><h2 id="Java技术体系"><a href="#Java技术体系" class="headerlink" title="Java技术体系"></a>Java技术体系</h2><h3 id="技术体系"><a href="#技术体系" class="headerlink" title="技术体系"></a>技术体系</h3><p>- </p><h3 id="cmd常用命令"><a href="#cmd常用命令" class="headerlink" title="cmd常用命令"></a>cmd常用命令</h3><h2 id=""><a href="#" class="headerlink" title="- "></a>- </h2><h3 id="开发步骤"><a href="#开发步骤" class="headerlink" title="开发步骤"></a>开发步骤</h3><h2 id="-1"><a href="#-1" class="headerlink" title="- "></a>- </h2><p>- </p><h2 id="Java基础语法"><a href="#Java基础语法" class="headerlink" title="Java基础语法"></a>Java基础语法</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><h2 id="-2"><a href="#-2" class="headerlink" title="- "></a>- </h2><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul><li><p>变量：存储数据的内存区域</p><ul><li>作用：存储数据</li></ul></li><li><p>• 类变量：独立于方法之外的变量，用 static 修饰。</p></li><li><p>• 实例变量：独立于方法之外的变量，不过没有 static 修饰。</p></li><li><p>• 局部变量：类的方法中的变量。</p></li></ul><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h2 id="-3"><a href="#-3" class="headerlink" title="- "></a>- </h2><h3 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h3><p>- </p><h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><h2 id="-4"><a href="#-4" class="headerlink" title="- "></a>- </h2><p>- </p><h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><h2 id="-5"><a href="#-5" class="headerlink" title="- "></a>- </h2><p>- </p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><ul><li><p>条件语句</p><ul><li><p>if语句</p><p>  - </p></li><li><p>switch语句</p><ul><li></li></ul></li></ul></li><li><p>循环语句</p><ul><li><p>for循环</p><p>  - </p></li><li><p>while循环</p><ul><li></li></ul></li></ul></li><li><p>调整控制语句</p><p>  - </p></li><li><p>Random 生成随机数</p><ul><li></li></ul></li></ul><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>数组中存储的元素并不是对象本身，而是对象的地址</li></ul><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><ul><li><p>什么是方法</p><p>  - </p></li><li><p>方法重载</p><h2 id="-6"><a href="#-6" class="headerlink" title="  - "></a>  - </h2><ul><li></li></ul></li></ul><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><h3 id="Java-面向对象"><a href="#Java-面向对象" class="headerlink" title="Java 面向对象"></a>Java 面向对象</h3><ul><li><p>面向对象</p><ul><li><ol><li>类：是对象共同特征的描述</li></ol></li><li><ol start="2"><li>对象：是真实存在的具体实例</li></ol></li><li><ol start="3"><li>在Java中，必须先设计类，才能创建对象并使用</li></ol></li><li><ol start="4"><li>创建类名：类名 对象名 = new 类名()；</li></ol></li><li><ol start="5"><li>类名首字母使用——驼峰模式</li></ol></li><li><ol start="6"><li>在Java文件中，可以定义多个class类，但只能有一个类是用public修饰，而且public修饰的类名必须是代码文件名</li></ol></li></ul></li><li><p>类的五大成分</p><ul><li><p>内存机制</p><ul><li>对象是放在堆内存里</li><li>Car c = new Car(); //c变量名中存储的是对象在堆内存中的地址</li><li>成员变量的数据放在对象中，存在堆内存中。</li><li>垃圾回收：当堆内存中的对象，没有被任何变量引用时，就会被判定位内存中的“垃圾”；</li><li>Java存在自动垃圾回收器，会定期进行清理。</li></ul></li><li><p>public class 类名 {}</p><ul><li><ol><li>成员变量 （对象的属性）</li></ol><ul><li>定义格式：public String getName; //一般不需要指定初始化值，存在默认值</li></ul></li><li><ol start="2"><li>成员方法 （对象的行为）</li></ol></li><li><ol start="3"><li>构造器</li></ol><ul><li><p>作用：定义在类中，可以用于初始化一个类的对象，并返回对象的地址</p><ul><li>分类：无参数构造器（初始化对象时，成员变量的数据均采用默认值）、有参数构造器（在初始化对象时，同时可以接受参数为对象进行赋值）</li><li>注意：任何类定义出来，默认就自带了无参数构造器，写不写都有；</li><li><pre><code>      ●一旦定义了有参数构造器，无参数构造器就没有了，此时就需要自己写无参数构造器了。</code></pre><ul><li><p>//无参数构造器</p><ul><li>public Car(){}</li></ul></li><li><p>//有参数构造器</p><ul><li>public Car(String n,int i){}</li></ul></li></ul></li></ul></li><li><p>this关键字</p><ul><li>• 可以出现在构造器、方法中；</li><li>• 代表当前对象的地址</li><li>• 可以用于指定访问当前对象的成员变量、成员方法</li></ul></li></ul></li><li><ol start="4"><li>代码块</li></ol></li><li><ol start="5"><li>内部类</li></ol></li></ul></li></ul></li><li><p>• 面向对象的三大特征：封装，继承，多态。</p><ul><li><p>• 封装：告诉我们，如何正确设计对象的属性和方法。</p><ul><li>• 封装的原则：对象代表什么，就得封装对应的数据，并提供数据对应的行为。</li><li>•  一般建议对成员变量使用private(私有、隐藏)关键字修饰,(private修饰的成员只能在当前类中访问)。</li></ul></li></ul></li><li><pre><code>JavaBean（实体类）</code></pre><p>其对象可以用于在程序中封装数据</p><p>  - </p></li><li><p>成员变量和局部变量的区别：</p><ul><li></li></ul></li></ul><h3 id="API"><a href="#API" class="headerlink" title="API"></a>API</h3><ul><li><p>㈠. 常用API</p><ul><li>●Java写好的技术（功能代码），咱们可以直接调用。</li><li>●Oracle也为ava提供的这些功能代码提供了相应的API文档（技术使用说明书）。</li></ul></li><li><p>㈡. String</p><ul><li><p>String类定义的变量可以用于存储字符串，同时String类提供了很多操作字符串的功能，我们可以直接使用。</p></li><li></li><li><p>String</p><ul><li><p>◆String类概述</p><ul><li><p>² java.lang.String类代表字符串，String类定义的变量可以用于指向字符串对象，然后操作该字符串。</p></li><li><p>² Java程序中的所有字符串文字（例如“abc”)都为此类的对象。</p></li><li><p>特点：</p><ul><li>► String其实常被称为不可变字符串类型，它的对象在创建后不能被更改。</li><li>► String变量每次的修改其实都是产生并指向了新的字符串对象。</li><li>► 原来的字符串对象都是没有改变的，所以称不可变字符串。</li></ul></li></ul></li><li><p>◆String类创建对象的2种方式</p><ul><li>方式一：直接使用””定义。     String name=”传智教育”；</li><li>方式二：通过String类的构造器创建对象。</li></ul></li><li></li></ul></li><li><p>◆String类常用API-遍历、替换、截取、分割操作</p><ul><li>◆String类常用API-字符串内容比较</li><li>字符串的内容比较不适合用“==”比较。</li><li>开发中使用基本数据类型比较时，使用==比较数据</li></ul></li></ul></li><li><p>(三) ArrayList</p><ul><li><p>ArrayList代表的是集合类，集合是一种容器，与数组类似，不同的是集合的大小是不固定的。</p></li><li><p>通过创建ArrayList的对象表示得到一个集合容器，同时ArrayList提供了比数组更好用，更丰富的API(功能)给程序员使用。</p></li><li></li><li><blockquote><p>ArrayList</p></blockquote><ul><li><p>◆集合概述</p><ul><li><p>数组：定义以后，类型确定，长度固定</p></li><li><p>ArrayList： 集合的大小不固定，启动后可以动态变化，类型也可以选择不固定。</p><ul><li> ·集合非常适合做元素个数不确定，且要进行增删操作的业务场景。</li><li> ·集合的提供了许多丰富、好用的功能，而数组的功能很单一。</li><li> ●集合适合做数据个数不确定，且要做增删元素的场景</li><li> ●数组适合做数据个数和类型确定的场景</li></ul></li><li><p>在定义集合时，必须采用泛型</p></li></ul></li></ul></li><li><p>◆ArrayList常用API、遍历</p><ul><li>ArrayList<object> list = new ArrayList&lt;&gt; ();<h3 id="static静态关键字"><a href="#static静态关键字" class="headerlink" title="static静态关键字"></a>static静态关键字</h3><ul><li><p>static是什么、修饰成员变量的用法</p></li><li><pre><code> static是静态的意思，可以修饰成员变量和成员方法。</code></pre><ul><li>static修饰成员变量表示该成员变量只在内存中只存储一份，可以被共享访问、修改。</li></ul></li><li><p>◆static修饰成员变量的内存原理</p></li><li><p>◆static修饰成员方法的基本用法</p></li><li><p>◆static修饰成员方法的内存原理</p></li><li><p>◆static的注意事项</p></li><li><blockquote></blockquote></li><li><p>㈡. static应用知识：工具类</p></li><li><p>工具类是什么？</p></li><li><p>·类中都是一些静态方法，每个方法都是以完成一个共用的功能为目的，这个类用来给系统开发人员共同使用的。</p></li><li><p>工具类的好处：一次编写，处处可用</p></li></ul><h3 id="代码块"><a href="#代码块" class="headerlink" title="代码块"></a>代码块</h3><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h2 id="API-1"><a href="#API-1" class="headerlink" title="API"></a>API</h2><h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><h3 id="时间-日期"><a href="#时间-日期" class="headerlink" title="时间 日期"></a>时间 日期</h3><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><h3 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h3><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><h3 id="Arrays"><a href="#Arrays" class="headerlink" title="Arrays"></a>Arrays</h3><h3 id="Lambda"><a href="#Lambda" class="headerlink" title="Lambda"></a>Lambda</h3><h3 id="集合-1"><a href="#集合-1" class="headerlink" title="集合"></a>集合</h3><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><ul><li><p>List</p><ul><li>ArrayList</li><li>LinkedList</li></ul></li><li><p>Set</p><ul><li><p>HashSet</p><ul><li>LinkedHashSet</li></ul></li><li><p>TreeSet</p></li></ul></li></ul><h3 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h3><ul><li><p>数据结构概述、栈、队列 </p><ul><li><p>数据结构概述</p><ul><li>数据结构是计算机底层存储、组织数据的方式。是指数据相互之间是以什么方式排列在一起的。</li><li>·通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率</li></ul></li></ul></li><li><p>栈</p><ul><li><p>栈数据结构的执行特点</p><ul><li>●后进先出，先进后出</li></ul></li><li><p>数据进入栈模型的过程称为：压/进栈</p></li><li><p>数据离开栈模型的过程称为：弹/出栈</p></li></ul></li><li><p>队列</p><ul><li><p>常见数据结构之队列</p><ul><li>●先进先出，后进后出</li></ul></li><li><p>数据从后端进入队列模型的过程称为：入队列</p></li><li><p>数据从前端离开队列模型的过程称为：出队列</p></li></ul></li><li><p>数组</p><ul><li>数组是一种查询快，增删慢的模型</li><li>●查询速度快：查询数据通过地址值和索引定位，查询任意数据耗时相同。（元素在内存中是连续存储的）</li><li>●删除效率低：要将原始数据删除，同时后面每个数据前移。</li><li>●添加效率极低：添加位置后的每个数据后移，再添加元素。</li></ul></li><li><p>链表</p><ul><li><p>链表的特点</p><ul><li>·链表中的元素是游离存储的，每个元素节点包含数据值和下一个元素的地址。</li><li>·链表查询慢。无论查询哪个数据都要从头开始找</li></ul></li><li><p>链表是一种增删快的模型（对比数组）</p></li><li><p>链表是一种查询慢的模型（对比数组）</p></li><li><p>链表的种类</p><ul><li>单向链表</li><li>双向链表</li></ul></li></ul></li><li><p>二叉树</p><ul><li>·只能有一个根节点，每个节点最多支特2个直接子节点。</li><li>·节点的度：节点拥有的子树的个数，二叉树的度不大于2</li><li>叶子节点度为0的节点，也称之为终端结点。</li><li>●高度：叶子结点的高度为1，叶子结点的父节点高度为2，</li><li>以此类推，根节点的高度最高。</li><li>·层：根节点在第一层，以此类推</li><li>●兄弟节点：拥有共同父节点的节点互称为兄弟节点</li></ul></li><li><p>二叉查找树</p><ul><li><p>二叉查找树又称二叉排序树或者二叉搜索树。</p></li><li><p>特点：</p><ul><li>●1，每一个节点上最多有两个子节点</li><li>·2,左子树上所有节点的值都小于根节点的值</li><li>●3，右子树上所有节点的值都大于根节点的值</li></ul></li><li><p>目的：提高检索数据的性能。</p></li><li><p>规则：</p><ul><li>小的存左边</li><li>大的存右边</li><li>一样的不存</li></ul></li></ul></li><li><p>平衡二叉树</p><ul><li><p>平衡二叉树是在满足查找二叉树的大小规则下，让树尽可能矮小，以此提高查数据的性能。</p></li><li><p>平衡二叉树在添加元素后可能导致不平衡</p><ul><li>●基本策略是进行左旋，或者右旋保证平衡。</li></ul></li><li><p>平衡二叉树-旋转的四种情况</p><ul><li><p>·左左</p><ul><li>当根节点左子树的左子树有节点插入，导致二叉树不平衡</li></ul></li><li><p>·左右</p><ul><li>当根节点左子树的右子树有节点插入，导致二叉树不平衡</li></ul></li><li><p>·右右</p><ul><li>当根节点右子树的右子树有节点插入，导致二叉树不平衡</li></ul></li><li><p>·右左</p><ul><li>当根节点右子树的左子树有节点插入导致二叉树不平衡</li></ul></li></ul></li></ul></li><li><p>红黑树</p><ul><li><p>概述</p><ul><li>·红黑树是一种自平衡的二叉查找树，是计算机科学中用到的一种数据结构。</li><li>●1972年出现，当时被称之为平衡二叉B树。1978年被修改为如今的”红黑树”。</li><li>·每一个节点可以是红或者黑；红黑树不是通过高度平衡的，它的平衡是通过“红黑规则”进行实现的。</li></ul></li><li><p>规则</p><ul><li>每一个节点或是红色的，或者是黑色的，根节点必须是黑色。</li><li>如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nl,这些N视为叶节点，叶节点是黑色的。</li><li>如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）。</li><li>·对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</li></ul></li><li><p>规则如下：</p><ul><li>。每一个节点或是红色的，或者是黑色的，根节点必须是黑色</li><li>。如果一个节点没有子节点或者父节点，则该节点相应的指针属性值为Nl,这些N视为叶节点，每</li><li>个叶节点(N是黑色的：</li><li>。如果某一个节点是红色，那么它的子节点必须是黑色（不能出现两个红色节点相连的情况）</li><li>●对每一个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。</li><li>红黑树增删改查的性能都很好</li></ul></li></ul></li><li><p>总结</p><ul><li>各种数据结构的特点和作用是什么样的</li><li>·队列：先进先出，后进后出。</li><li>●栈：后进先出，先进后出。</li><li>数组：内存连续区域，查询快，增删慢。</li><li>链表：元素是游离的，查询慢，首尾操作极快。</li><li>二叉树：永远只有一个根节点，每个结点不超过2个子节点的树。</li><li>●查找二叉树：小的左边，大的右边，但是可能树很高，查询性能变差。</li><li>平衡查找二叉树：让树的高度差不大于1，增删改查都提高了。</li><li>。红黑树（就是基于红黑规则实现了自平衡的排序二叉树）</li></ul></li></ul><h3 id="List系列集合"><a href="#List系列集合" class="headerlink" title="List系列集合"></a>List系列集合</h3><ul><li><p>List系列集合特点</p><ul><li><p>ArrayList、LinkedList:有序，可重复，有索引。</p></li><li><p>有序：存储和取出的元素顺序一致</p></li><li><p>有索引：可以通过索引操作元素</p></li><li><p>可重复：存储的元素可以重复</p></li><li><p>总结</p><ul><li><p>1、List系列集合特点</p><ul><li>●ArrayList、LinkedList:有序，可重复，有索引。</li></ul></li><li><p>2、List的实现类的底层原理</p><ul><li>ArrayList)底层是基于数组实现的，根据查询元素快，增删相对慢。</li><li>LinkedList底层基于双链表实现的，查询元素慢，增删首尾元素是非常快的。</li></ul></li></ul></li></ul></li><li><p>List集合的遍历方式有几种？</p><ul><li>迭代器</li><li>增强for循环</li><li>Lambda表达式</li><li>for循环（因为List集合存在索引）</li></ul></li><li><p>ArrayList集合底层原理</p><ul><li>ArrayList底层是基于数组实现的：根据索引定位元素快，增删需要做元素的移位操作。</li><li>第一次创建集合并添加第一个元素的时候，在底层创建一个默认长度为10的数组。</li></ul></li><li><p>LinkedList的特点</p><ul><li>底层数据结构是双链表，查询慢，首尾操作的速度是极快的，所以多了很多首尾操作的特有API。</li></ul></li></ul><h3 id="补充知识：集合的并发修改异常问题"><a href="#补充知识：集合的并发修改异常问题" class="headerlink" title="补充知识：集合的并发修改异常问题"></a>补充知识：集合的并发修改异常问题</h3><ul><li><p>问题引出</p><ul><li>当我们从集合中找出某个元素并删除的时候可能出现一种并发修改异常问题。</li></ul></li><li><p>哪些遍历存在问题？</p><ul><li>迭代器遍历集合且直接用集合删除元素的时候可能出现。</li><li>增强for循环遍历集合且直接用集合删除元素的时候可能出现。</li></ul></li><li><p>哪种遍历且删除元素不出问题</p><ul><li>●迭代器遍历集合但是用迭代器自己的删除方法操作可以解决。</li><li>使用for循环遍历并删除元素不会存在这个问题。</li></ul></li><li><p>解决办法</p><ul><li>a、选代器遍历删除</li><li>b、foreach追历删除</li><li>c、Lambda表达式</li><li>d、for循环</li></ul></li></ul><h3 id="补充知识：泛型深入"><a href="#补充知识：泛型深入" class="headerlink" title="补充知识：泛型深入"></a>补充知识：泛型深入</h3><ul><li><p>泛型概述</p><ul><li>泛型：是DK5中引入的特性，可以在编译阶段约束操作的数据类型，并进行检查。</li><li>泛型的格式：&lt;数据类型&gt;；注意：泛型只能支持引用数据类型。</li><li>集合体系的全部接口和实现类都是支持泛型的使用的。</li></ul></li><li><p>泛型的好处：</p><ul><li>统一数据类型。</li><li>把运行时期的问题提前到了编译期间，避免了强制类型转换可能出现的异常，因为编译阶段类型就能确定下来。</li></ul></li><li><p>泛型可以在很多地方进行定义：</p><ul><li><p>类后面</p><ul><li>泛型类</li></ul></li><li><p>方法申明上</p><ul><li>泛型方法</li></ul></li><li><p>接口后面</p><ul><li>泛型接口</li></ul></li></ul></li><li><p>泛型类的概述</p><ul><li><p>定义类时同时定义了泛型的类就是泛型类。</p></li><li><p>泛型类的格式：修饰符class类名&lt;泛型变量&gt;}</p><ul><li>范例：public class MyArrayList<t>{}</t></li></ul></li><li><p>1、泛型类的核心思想：</p><ul><li>●把出现泛型变量的地方全部替换成传输的真实数据类型</li></ul></li><li><p>2、泛型类的作用</p><ul><li>·编译阶段约定操作的数据的类型，类似于集合的作用。</li></ul></li></ul></li><li><p>泛型方法的概述</p><ul><li><p>定义方法时同时定义了泛型的方法就是泛型方法。</p></li><li><p>泛型方法的格式：修饰符&lt;泛型变量&gt;方法返回值方法名称（形参列表）（）</p></li><li><p>范例：public<t>void show(Tt)(}</t></p></li><li><p>作用：方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性。</p></li><li><p>1、泛型方法的核心思想：</p><ul><li>●把出现泛型变量的地方全部替换成传输的真实数据类型</li></ul></li><li><p>2、泛型方法的作用</p><ul><li>。方法中可以使用泛型接收一切实际类型的参数，方法更具备通用性</li></ul></li></ul></li><li><p>泛型接口的概述</p><ul><li><p>●使用了泛型定义的接口就是泛型接口。</p></li><li><p>●泛型接口的格式：修饰符interface接口名称&lt;泛型变量&gt;</p><ul><li>范例：public interface Data<e></e></li></ul></li><li><p>作用：泛型接口可以让实现类选择当前功能需要操作的数据类型</p></li><li><p>泛型接口的原理：</p><ul><li>实现类可以在实现接口的时候传入自己操作的数据类型，这样重写的方法都将是针对于该类型的操作。</li></ul></li><li><p>1、泛型接口的作用</p><ul><li>泛型接口可以约束实现类，实现类可以在实现接口的时候传入自己操作的数据类型这样重写的方法都将是针对于该类型的操作。</li></ul></li></ul></li><li><p>泛型的通配符</p><ul><li><p>？</p><ul><li><p>●？可以在“使用泛型”的时候代表一切类型。</p></li><li><p>●ETKV是在定义泛型的时候使用的。</p></li><li><p>虽然BMW和BENZ都继承了Car但是ArrayList<bmw>和ArrayList<benz>与ArrayList<car>没有关系的！！</car></benz></bmw></p></li><li><p>泛型的上下限：</p><ul><li>？extends Car:?必须是Car或者其子类   泛型上限</li><li>？super Car:?必须是Car或者其父类     泛型下限</li></ul></li></ul></li></ul></li></ul><h3 id="Set集合系列"><a href="#Set集合系列" class="headerlink" title="Set集合系列"></a>Set集合系列</h3><ul><li><p>Set系列集系概述</p><ul><li><p>Set系列集合特点</p><ul><li>无序：存取顺序不一致</li><li>不重复：可以去除重复</li><li>无索引：没有带索引的方法，所以不能使用普通for循环遍历，也不能通过索引来获取元素。</li></ul></li><li><p>Set集合实现类特点</p><ul><li>HashSet:无序、不重复、无索引。</li><li>LinkedHashSet:有序、不重复、无索引。</li><li>TreeSet:排序、不重复、无索引。</li></ul></li></ul></li><li><p>HashSet元素无序的底层原理：哈希表</p><ul><li><p>HashSet,底层原理</p><ul><li>●HashSets集合底层采取哈希表存储的数据。</li><li>●哈希表是一种对于增删改查数据性能都较好的结构。</li></ul></li><li><p>哈希表的组成</p><ul><li>JDK8之前的，底层使用数组+链表组成</li><li>JDK8开始后，底层采用数组+链表+红黑树组成。</li></ul></li><li><p>哈希表</p><ul><li><p>哈希值</p><ul><li><p>哈希值</p><ul><li>●是DK根据对象的地址，按照某种规则算出来的it类型的数值。</li></ul></li><li><p>Object类的API</p><ul><li>●public int hashCode():返回对象的哈希值</li></ul></li><li><p>对象的哈希值特点</p><ul><li>●同一个对象多次调用hashCode()方法返回的哈希值是相同的</li><li>·默认情况下，不同对象的哈希值是不同的。</li></ul></li><li><p>HashSet 1.7</p><ul><li>数组+链表+（结合哈希算法）</li><li>结论：哈希表是一种对于增删改查数据性能都较好的结构。</li></ul></li><li><p>HashSet 1.8</p><ul><li>数组 + 链表 + 红黑树</li><li>哈希表对于红黑树的引入进一步提高了操作数据的性能。</li></ul></li></ul></li><li><p>2.哈希表的详细流程</p><ul><li>①创建一个默认长度16，默认加载因为0.75的数组，数组名table</li><li>②根据元素的哈希值跟数组的长度计算出应存入的位置</li><li>③判断当前位置是否为nu,如果是nul直接存入，如果位置不为nul,表示有元素</li><li>,则调用equals方法比较属性值，如果一样，则不存，如果不一样，则存入数组。</li><li>④当数组存满到16*0.75=12时，就自动扩容，每次扩容原先的两倍</li></ul></li></ul></li></ul></li><li><p>HashSet元素去重复的底层原理</p><ul><li><p>创建一个默认长度16的数组，数组名table</p></li><li><p>根据元素的哈希值跟数组的长度求余计算出应存入的位置（哈希算法）</p></li><li><p>判断当前位置是否为nul,如果是null直接存入</p></li><li><p>如果位置不为null,表示有元素，则调用equals方法比较</p></li><li><p>如果一样，则不存，如果不一样，则存入数组，</p></li><li><p>结论：如果希望Set集合认为2个内容一样的对象是重复的，必须重写对象的hashCode()和equals()方法</p></li><li><p>如果希望Set集合认为2个内容相同的对象是重复的应该怎么办？</p><ul><li>●重写对象的hashCode和equals方法。</li></ul></li></ul></li><li><p>实现类：LinkedHashSet</p><ul><li>·有序、不重复、无索引。</li><li>●这里的有序指的是保证存储和取出的元素顺序一致</li><li>·原理：底层数据结构是依然哈希表，只是每个元素又额外的多了一个双链表的机制记录存储的顺序。</li></ul></li><li><p>实现类：TreeSet</p><ul><li><p>TreeSet集合概述和特点</p><ul><li>不重复、无索引、可排序</li><li>可排序：按照元素的大小默认升序（有小到大）排序。</li><li>TreeSet集合底层是基于红黑树的数据结构实现排序的，增删改查性能都较好。</li><li>注意：Treeset集合是一定要排序的，可以将元素按照指定的规则进行排序。</li></ul></li><li><p>TreeSet集合默认的规则</p><ul><li>对于数值类型：Integer,Double,官方默认按照大小进行升序排序。</li><li>对于字符串类型：默认按照首字符的编号升序排序。</li><li>●对于自定义类型如Student对象，TreeSet无法直接排序。</li><li>结论：想要使用TreeSet存储自</li><li>定义类型，需要制定排序规则</li></ul></li><li><p>自定义排序规则</p><ul><li><p>TreeSet:集合存储对象的的时候有2种方式可以设计自定义比较规侧则</p></li><li><p>方式一</p><ul><li>·让自定义的类（如学生类）</li><li>实现Comparable接口重写里面的compareTo方法来定制比较规则。</li></ul></li><li><p>方式二</p><ul><li>●TreeSet:集合有参数构造器，可以设置Comparator接口对应的比较器对象，来定制北比较规则。</li></ul></li><li><p>两种方式中，关于返回值的规则：</p><ul><li>,如果认为第一个元素大于第二个元素返回正整数即可。</li><li>如果认为第一个元素小于第二个元素返回负整数即可。</li><li>如果认为第一个元素等于第二个元素返回0即可，此时Treeset:集合只会保留一个元素，认为两者重复。</li></ul></li><li><p>注意：如果TreeSet:集合存储的对象有实现比较规则，集合也自带比较器，默认使用集合自带的比较器排序。</p></li></ul></li></ul></li></ul><h3 id="Collection体系的特点、使用场景总结"><a href="#Collection体系的特点、使用场景总结" class="headerlink" title="Collection体系的特点、使用场景总结"></a>Collection体系的特点、使用场景总结</h3><ul><li><p>1.如果希望元素可以重复，又有索引，索引查询要快？</p><ul><li>●用ArrayList集合，基于数组的。（用的最多）</li></ul></li><li><p>2.如果希望元素可以重复，又有索引，增删首尾操作快？</p><ul><li>●用LinkedList集合，基于链表的。</li></ul></li><li><p>3.如果希望增删改查都快，但是元素不重复、无序、无索引。</p><ul><li>●用HashSet:集合，基于哈希表的。</li></ul></li><li><p>4.如果希望增删改查都快，但是元素不重复、有序、无索引。</p><ul><li>●用LinkedHashSet:集合，基于哈希表和双链表。</li></ul></li><li><p>5.如果要对对象进行排序。</p><ul><li>●用TreeSet集合，基于红黑树。后续也可以用List集合实现排序。</li></ul></li></ul><h3 id="补充知识：可变参数"><a href="#补充知识：可变参数" class="headerlink" title="补充知识：可变参数"></a>补充知识：可变参数</h3><ul><li><p>可变参数</p><ul><li><p>·可变参数用在形参中可以接收多个数据。</p></li><li><p>可变参数的格式：数据类型 … 参数名称</p></li><li><p>可变参数的作用</p><ul><li>·传输参数非常灵活，方便。可以不传输参数，可以传输1个或者多个，也可以传输一个数组</li><li>可变参数在方法内部本质上就是一个数组。</li></ul></li><li><p>可变参数的注意事项：</p><ul><li>●1.一个形参列表中可变参数只能有一个</li><li>●2.可变参数必须放在形参列表的最后面</li></ul></li></ul></li></ul><h3 id="补充知识：集合工具类Collections"><a href="#补充知识：集合工具类Collections" class="headerlink" title="补充知识：集合工具类Collections"></a>补充知识：集合工具类Collections</h3><ul><li><p>Collections集合工具类</p><ul><li>●java.utils.Collections:是集合工具类</li><li>·作用：Collections并不属于集合，是用来操作集合的工具类。</li></ul></li><li><p>Collections常用的API</p><ul><li><p>public static <t>boolean addAll(Collection&lt;?super T&gt;c,T…elements)</t></p><ul><li>给集合对象批量添加元素</li></ul></li><li><p>public static void shuffle(List&lt;?&gt;list)</p><ul><li>打乱List集合元素的顺序</li></ul></li></ul></li><li><p>Collections:排序相关API</p><ul><li><p>●使用范围：只能对于List集合的排序。</p><ul><li><p>public static <t>void sort(List<t>list)</t></t></p><ul><li>将集合中元素按照默认规则排序</li><li>注意：本方式不可以直接对自定义类型的List集合排序，除非自定义类型实现了比较规则Comparable接口。</li></ul></li><li><p>public static <t>void sort(List<t>list,Comparator&lt;?super T&gt;c)</t></t></p><ul><li>将集合中元素按照指定规则排序</li></ul></li></ul></li></ul></li></ul><h3 id="Map集合系列"><a href="#Map集合系列" class="headerlink" title="Map集合系列"></a>Map集合系列</h3><ul><li><p>Map集合的概述</p><ul><li><p>Map集合概述和使用</p><ul><li>Map集合是一种双列集合(键值对集合)，每个元素包含两个数据。</li><li>Map集合的每个元素的格式：key=value(键值对元素)。</li><li>Map集合也被称为“键值对集合”。</li></ul></li><li><p>Map集合整体格式：</p><ul><li>Collection集合的格式：[元素1，元素2，元素3.]</li><li>Map集合的完整格式：{key1=value1,key2=value2,key3=value.3,.}</li></ul></li></ul></li><li><p>Map集合体系特点</p><ul><li><p>Map</p><ul><li><p>HashMap</p><ul><li>LinkedHashMap</li></ul></li><li><p>HashTable</p><ul><li>Properties</li></ul></li><li><p>AbstractMap</p><ul><li>TreeMap</li></ul></li></ul></li><li><p>体系特点</p><ul><li>●Map集合的特点都是由键决定的。</li><li>●Mp集合的键是无序，不重复的，无索引的，值不做要求（可以重复）。</li><li>●Map集合后面重复的键对应的值会覆盖前面重复键的值。</li><li>●Map集合的键值对都可以为null。</li></ul></li><li><p>实现类特点</p><ul><li>HashMap:元素按照键是无序，不重复，无索引，值不做要求。（与Map体系一致）</li><li>LinkedHashMap:元素按照键是有序，不重复，无索引，值不做要求。</li><li>TreeMap:元素按照建是排序，不重复，无索引的，值不做要求。</li></ul></li></ul></li><li><p>Map集合常用API</p><ul><li><p>Map集合</p><ul><li>Map是双列集合的祖宗接口，它的功能是全部双列集合都可以继承使用的。</li><li></li></ul></li></ul></li><li><p>Map集合的遍历</p><ul><li><p>Map集合的遍历方式一：键找值</p><ul><li><p>先获取Map集合的全部键的Set集合。</p></li><li><p>遍历键的Set集合，然后通过键提取对应值。</p></li><li><p>键找值涉及到的API:</p><ul><li><p>Set<k>keySet()D</k></p><ul><li>获取所有键的集合</li></ul></li><li><p>V get(Object key)</p><ul><li>根据键获取值</li></ul></li></ul></li></ul></li><li><p>Map集合的遍历方式二：键值对</p><ul><li><p>先把Map集合转换成Set集合，Set集合中每个元素都是键值对实体类型了。</p></li><li><p>遍历Set集合，然后提取键以及提取值。</p></li><li><p>键值对涉及到的API:</p><ul><li><p>Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet()</p><ul><li>获取所有键值对对象的集合</li></ul></li><li><p>K getKey0</p><ul><li>获得键</li></ul></li><li><p>V getValue()</p><ul><li>获取值</li></ul></li></ul></li></ul></li><li><p>Map集合的遍历方式三：lambda表达式</p><ul><li><p>得益于JDK8开始的新技术Lambda表达式，提供了一种更简单、更直接的遍历集合的方式。</p></li><li><p>Map结合Lambda遍历的APl</p><ul><li><p>default void forEach(BiConsumer&lt;?super K,super V&gt;action)</p><ul><li>结合lambdai遍历Map集合</li></ul></li></ul></li></ul></li></ul></li><li><p>Map集合的实现类HashMap</p><ul><li><p>HashMap的特点</p><ul><li>●HashMap是Map里面的一个实现类。特点都是由键决定的：无序、不重复、无索引</li><li>●没有额外需要学习的特有方法，直接使用Map里面的方法就可以了。</li><li>●HashMap跟HashSet)底层原理是一模一样的，都是哈希表结构，只是HashMap的每个元素包含两个值而已。</li></ul></li><li><p>实际上：Set系列集合的底层就是Map实现的，只是Set集合中的元素只要键数据，不要值数据而已。</p></li><li><p>HashMap的特点和底层原理</p><ul><li>●由键决定：无序、不重复、无索引。HashMap底层是哈希表结构的。</li><li>●依赖hashCode方法和equals方法保证键的唯一。</li><li>如果键要存储的是自定义对象，需要重写hashCode和equals方法。</li><li>●基于哈希表。增删改查的性能都较好。</li></ul></li></ul></li><li><p>Map集合的实现类LinkedHashMap</p><ul><li><p>LinkedHashMap集合概述和特点</p><ul><li>·由键决定：有序、不重复、无索引。</li><li>●这里的有序指的是保证存储和取出的元素顺序一致</li></ul></li><li><p>·原理：底层数据结构是依然哈希表，只是每个键值对元素又额外的多了一个双链表的机制记录存储的顺序。</p></li></ul></li><li><p>Map集合的实现类TreeMap</p><ul><li><p>TreeMap集合概述和特点</p><ul><li>由键决定特性：不重复、无索引、可排序</li><li>可排序：按照键数据的大小默认升序（有小到大)排序。只能对键排序。</li><li>,注意：TreeMap:集合是一定要排序的，可以默认排序，也可以将键按照指定的规则进行排序</li></ul></li><li><p>TreeMap跟TreeSet-一样底层原理是一样的。</p></li><li><p>TreeMap集合自定义排序规则有2种</p><ul><li>类实现Comparable接口，重写比较规则。</li><li>●集合自定义Comparator比较器对象，重写比较规则。</li></ul></li></ul></li><li><p>Map集合实现类特点</p><ul><li>●HashMap:元素按照键是无序，不重复，无索引，值不做要求，基于哈希表（与Map体系一致）</li><li>●LinkedHashMap:元素按照键是有序，不重复，无索引，值不做要求，基于哈希表</li><li>●TreeMap:元素只能按照键排序，不重复，无索引的，值不做要求，可以做排序</li></ul></li></ul><h3 id="补充知识：集合的嵌套"><a href="#补充知识：集合的嵌套" class="headerlink" title="补充知识：集合的嵌套"></a>补充知识：集合的嵌套</h3><h2 id="Stream、异常体系、日志框架"><a href="#Stream、异常体系、日志框架" class="headerlink" title="Stream、异常体系、日志框架"></a>Stream、异常体系、日志框架</h2><h3 id="今天同学们需要学会什么"><a href="#今天同学们需要学会什么" class="headerlink" title="今天同学们需要学会什么"></a>今天同学们需要学会什么</h3><ul><li><p>不可变集合</p><ul><li>有些业务场景下需要有不可变集合对象，Java如何得到不可变集合对象</li></ul></li><li><p>Streami流</p><ul><li>集合自己提供的API非常繁琐，JDK8开始，得益于Lambda,提供了操作集合、数组更好用的技术：Stream</li></ul></li><li><p>认识异常体系</p><ul><li>程序一旦出现了bug则会终止，如何尽力避免程序出现异常，出现异常如何进行处理让程序更稳健</li></ul></li><li><p>日志框架</p><ul><li>系统在开发阶段或者上线后，一旦业务出现问题，需要有信息去定位，如何记录程序的运行情况？</li></ul></li></ul><h3 id="不可变集合"><a href="#不可变集合" class="headerlink" title="不可变集合"></a>不可变集合</h3><ul><li><p>什么是不可变集合？</p><ul><li>不可变集合，就是不可被修改的集合。</li><li>集合的数据项在创建的时候提供，并且在整个生命周期中都不可改变。否则报错。</li></ul></li><li><p>为什么要创建不可变集合？</p><ul><li>如果某个数据不能被修改，把它防御性地拷贝到不可变集合中是个很好的实践。</li><li>。或者当集合对象被不可信的库调用时，不可变形式是安全的。</li></ul></li><li><p>如何创建不可变集合？</p><ul><li><p>。在List、Set、Map接口中，都存在of方法，可以创建一个不可变的集合。</p></li><li><p>方法</p><ul><li><p>static <e>List<e>of(E…elements)</e></e></p><ul><li>创建一个具有指定元素的List集合对像</li></ul></li><li><p>static <e>Set<e>of(E…elements)</e></e></p><ul><li>创建一个具有指定元素的Set集合对像</li></ul></li><li><p>static &lt;K,V&gt;Map&lt;K,V&gt;of(E…elements)</p><ul><li>创建一个具有指定元素的Map集合对像</li></ul></li></ul></li></ul></li><li><p>问题</p><ul><li><p>1.不可变集合的特点？</p><ul><li>●定义完成后不可以修改，或者添加、删除</li></ul></li><li><p>2.如何创建不可变集合？</p><ul><li>●List、Set、Map接口中，都存在of方法可以创建不可变集合。</li></ul></li></ul></li></ul><h3 id="Streami流"><a href="#Streami流" class="headerlink" title="Streami流"></a>Streami流</h3><ul><li><p>◆Stream流的概述</p><ul><li><p>什么是Stream流？</p><ul><li>在ava8中，得益于Lambda所带来的函数式编程，引入了一个全新的Stream流概念。</li><li>●目的：用于简化集合和数组操作的API。</li></ul></li><li><p>体验Stream流的作用</p><ul><li>简化集合、数组操作的API。结合了Lambda表达式。</li></ul></li><li><p>Stream流式思想的核心：</p><ul><li>1.先得到集合或者数组的Stream流（就是一根传送带）</li><li>2.把元素放上去</li><li>3.然后就用这个Stream流简化的API来方便的操作元素。</li></ul></li></ul></li><li><p>◆Stream流的获取</p><ul><li><p>Stream流的三类方法</p><ul><li><p>获取Stream流</p><ul><li>创建一条流水线，并把数据放到流水线上准备进行操作</li></ul></li><li><p>中间方法</p><ul><li>■流水线上的操作。一次操作完毕之后，还可以继续进行其他操作。</li></ul></li><li><p>终结方法</p><ul><li>■一个Stream流只能有一个终结方法，是流水线上的最后一个操作</li></ul></li></ul></li><li><p>集合获取Stream流的方式</p><ul><li><p>Stream操作集合或者数组的第一步是先得到Stream流，然后才能使用流的功能。</p></li><li><p>可以使用Collection接口中的默认方法stream(）生成流</p><ul><li><p>default Stream<e>stream()</e></p><ul><li>获取当前集合对象的Stream流</li></ul></li></ul></li><li><p>数组获取Stream流的方式</p><ul><li><p>public static <t>StreamT&gt;stream(T[]array)</t></p><ul><li>获取当前数组的Stream流</li></ul></li><li><p>public static<t>Stream<t>of(T…values)</t></t></p><ul><li>获取当前数组/可变数据的Stream流</li></ul></li></ul></li></ul></li></ul></li><li><p>◆Stream流的常用API</p><ul><li><p>Stream流的常用API(中间操作方法)</p><ul><li><p>Stream<t>filter(Predicate&lt;?super T&gt;predicate)</t></p><ul><li>用于对流中的数据进行过滤。</li></ul></li><li><p>Stream<t>limit(long maxSize)</t></p><ul><li>获取前几个元素</li></ul></li><li><p>Stream<t>skip(long n)</t></p><ul><li>跳过前几个元素</li></ul></li><li><p>Stream<t>distinct()</t></p><ul><li>去除流中重复的元素。依赖(hashCode和equals方法)</li></ul></li><li><p>static <t>Stream<t>concat(Stream a,Stream b)</t></t></p><ul><li>合并a和b两个流为一个流</li></ul></li><li><p>注意：</p><ul><li>中间方法也称为非终结方法，调用完成后返回新的Stream流可以继续使用，支持链式编程。</li><li>在Stream流中无法直接修改集合、数组中的数据。</li></ul></li></ul></li><li><p>Stream流的常见终结操作方法</p><ul><li><p>void forEach(Consumer action)</p><ul><li>对此流的每个元素执行遍历操作</li></ul></li><li><p>long count()</p><ul><li>返回此流中的元素数</li></ul></li><li><p>注意：终结操作方法，调用完成后流就无法继续使用了，原因是不会返回Stream了。</p></li></ul></li><li><p>1、终结和非终结方法的含义是什么？</p><ul><li>·终结方法后流不可以继续使用，非终结方法会返回新的流，支持链式编程。</li></ul></li></ul></li><li><p>◆收集Stream流</p><ul><li><p>Stream流的收集操作</p><ul><li>●收集Stream流的含义：就是把Stream流操作后的结果数据转回到集合或者数组中去。</li><li>●Stream流：方便操作集合/数组的手段。</li><li>●集合/数组：才是开发中的目的。</li></ul></li><li><p>Stream流的收集方法</p><ul><li><p>R collect(Collector collector)</p><ul><li>开始收集Stream流，指定收集器</li></ul></li></ul></li><li><p>Collectors工具类提供了具体的收集方式</p><ul><li><p>public static <t>Collector toList()</t></p><ul><li>把元素收集到List集合中</li></ul></li><li><p>public static <t>Collector toSet()</t></p><ul><li>把元素收集到Set集合中</li></ul></li><li><p>public static Collector toMap(Function keyMapper,Function valueMapper)</p><ul><li>把元素收集到Map集合中</li></ul></li></ul></li><li><p>1、收集Stream流的作用？</p><ul><li>●Stream流是操作集合/数组的手段</li><li>·操作的结果数据最终要恢复到集合或者数组中去。</li></ul></li></ul></li></ul><h3 id="认识异常体系"><a href="#认识异常体系" class="headerlink" title="认识异常体系"></a>认识异常体系</h3><ul><li><p>异常概述、体系</p><ul><li><p>什么是异常？</p><ul><li>·异常是程序在“编译”或者“执行”的过程中可能出现的问题，注意：语法错误不算在异常体系中。</li><li>比如：数组索引越界、空指针异常、日期格式化异常，等…</li></ul></li><li><p>为什么要学习异常？</p><ul><li>异常一旦出现了，如果没有提前处理，程序就会退出JVM虚拟机而终止，</li><li>研究异常并且避免异常，然后提前处理异常，体现的是程序的安全，健壮性。</li></ul></li><li><p>异常体系</p><ul><li><p>Throwable</p><ul><li><p>Error</p><ul><li>·系统级别问题、JVM退出等，代码无法控制。</li></ul></li><li><p>Exception</p><ul><li><p>RuntimeException</p><ul><li>●RuntimeException及其子类：运行时异常，编译阶段不会报错。（空指针异常，数组索引越界异常）</li></ul></li><li><p>除RuntimeException之外所有的异常</p><ul><li>除RuntimeException之外所有的异常：编译时异常，编译期必须处理的，否则程序不能通过编译。（日期格式化异常）。</li></ul></li><li><p>Exception:java.lang包下，称为异常类，它表示程序本身可以处理的问题</p></li></ul></li></ul></li></ul></li><li><p>学习异常的目的？</p><ul><li>避免异常的出现，同时处理可能出现的异常，让代码更稳健。</li></ul></li></ul></li><li><p>常见运行时异常</p><ul><li><p>运行时异常，在编译成clss文件不需要处理，在运行字节码文件时可能出现的异常。</p></li><li><p>●直接继承自RuntimeException.或者其子类，编译阶段不会报错，运行时可能出现的错误。</p></li><li><p>运行时异常：一般是程序员业务设有考虑好或者是编程逻辑不严谨引起的程序错误，</p></li><li><p>运行时异常示例</p><ul><li>数组索引越界异常：ArraylndexOutOfBoundsException</li><li>空指针异常：NullPointerException,直接输出没有问题，但是调用空指针的变量的功能就会报错。</li><li>数学操作异常：ArithmeticException</li><li>类型转换异常：ClassCastException</li><li>数字转换异常：NumberFormatException</li></ul></li></ul></li><li><p>常见编译时异常</p><ul><li><p>●编译时异常，是在编译成clss文件时必须要处理的异常，也称之为受检异常</p></li><li><p>不是RuntimeException或者其子类的异常，编译阶就报错，必须处理，否则代码不通过。</p></li><li><p>编译时异常的作用是什么：</p><ul><li>●是担心程序员的技术不行，在编译阶段就爆出一个错误，目的在于提醒不要出错！</li><li>●编译时异常是可遇不可求。遇到了就遇到了呗。</li></ul></li></ul></li><li><p>异常的默认处理流程</p><ul><li>①默认会在出现异常的代码那里自动的创建一个异常对象：ArithmeticException。</li><li>②异常会从方法中出现的点这里抛出给调用者，调用者最终抛出给JVM虚拟机。</li><li>③虚拟机接收到异常对象后，先在控制台直接输出异常栈信息数据。</li><li>④直接从当前执行的异常点干掉当前程序。</li><li>⑤后续代码没有机会执行了，因为程序已经死亡。</li><li>默认的异常处理机制并不好，一旦真的出现异常，程序立即死亡！</li></ul></li><li><p>编译时异常的处理机制</p><ul><li><p>编译时异常是编译阶段就出错的，所以必须处理，否则代码根本无法通过</p></li><li><p>编译时异常的处理形式有三种：</p><ul><li><p>●出现异常直接抛出去给调用者，调用者也继续抛出去。</p><ul><li><p>异常处理方式1——throws</p><ul><li>●throws:用在方法上，可以将方法内部出现的异常抛出去给本方法的调用者处理。</li><li>·这种方式并不好，发生异常的方法自己不处理异常，如果异常最终抛出去给虚拟机将引起程序死亡。</li></ul></li><li><p>异常处理方式2一try..catch..</p><ul><li>●监视捕获异常，用在方法内部，可以将方法内部出现的异常直接捕获处理。</li><li>·这种方式还可以，发生异常的方法自己独立完成异常的处理，程序可以继续往下执行。</li></ul></li><li><p>异常处理方式3—一前两者结合</p><ul><li>●方法直接将异通过throws抛出去给调用者</li><li>调用者收到异常后直接捕获处理。</li></ul></li><li><p>1、异常处理的总结</p><ul><li>●在开发中按照规范来说第三种方式是最好的：底层的异常抛出去给最外层，最外层集中捕获处理。</li><li>●实际应用中，只要代码能够编译通过，并且功能能完成，那么每一种异常处理方式似乎也都是可以的。</li></ul></li></ul></li><li><p>●出现异常自己捕获处理，不麻烦别人。</p></li><li><p>●前两者结合，出现异常直接抛出去给调用者，调用者捕获处理。</p></li></ul></li></ul></li><li><p>运行时异常的处理机制</p><ul><li><p>运行时异常的处理形式</p><ul><li>●运行时异常编译阶段不会出错，是运行时才可能出错的，所以编译阶段不处理也可以。</li><li>●按照规范建议还是处理：建议在最外层调用处集中捕获处理即可。</li></ul></li></ul></li><li><p>自定义异常</p><ul><li><p>自定义异常的必要？</p><ul><li>●Java无法为这个世界上全部的问题提供异常类。</li><li>●如果企业想通过异常的方式来管理自己的某个业务问题，就需要自定义异常类了。</li></ul></li><li><p>自定义异常的好处：</p><ul><li>●可以使用异常的机制管理业务问题，如提醒程序员注意。</li><li>●同时一旦出现bug,可以用异常的形式清晰的指出出错的地方。</li></ul></li><li><p>自定义异常的分类</p><ul><li><p>1、自定义编译时异常</p><ul><li>定义一个异常类继承Exception.</li><li>重写构造器。</li><li>在出现异常的地方用throw new自定义对象抛出，</li><li>作用：编译时异常是编译阶段就报错，提醒更加强烈，一定需要处理！！</li></ul></li><li><p>2、自定义运行时异常</p><ul><li>●定义一个异常类继承RuntimeException.</li><li>●重写构造器。</li><li>●在出现异常的地方用throw new自定义对象抛出！</li><li>作用：提醒不强烈，编译阶段不报错！！运行时才可能出现！！</li></ul></li><li><p>throw；在方法内部直接创建一个异常对象，并从此抛出</p></li><li><p>throws:用在方法申明上的，抛出方法内部的异清异常</p></li></ul></li></ul></li></ul><h3 id="日志框架"><a href="#日志框架" class="headerlink" title="日志框架"></a>日志框架</h3><ul><li><p>今天同学们需要学会什么</p><ul><li><p>日志框架</p><ul><li>系统在开发阶段或者上线后，一旦业务出现问题，需要有信息去定位，如何记录程序的运行信息？</li></ul></li><li><p>阶段项目</p><ul><li>学以致用，使用Java程序处理数据、控制业务逻辑推进。</li></ul></li></ul></li><li><p>◆日志技术的概述</p><ul><li><p>日志技术具备的优势</p><ul><li>·可以将系统执行的信息选择性的记录到指定的位置（控制台、文件中、数据库中）。</li><li>●可以随时以开关的形式控制是否记录日志，无需修改源代码。</li></ul></li><li></li></ul></li><li><p>◆日志技术体系结构</p><ul><li>日志规范：一些接口，提供给日志的实现框架设计的标准。</li><li>日志框架：牛人或者第三方公司已经做好的日志记录实现代码，后来者直接可以拿去使用。</li><li>Commons Logging（JCL）</li><li>Simple Logging Facade for Java（slf4j）</li><li>因为对Commons Logging的接口不满意，有人就搞了SLF4。因为对Log4j的性能不满意，有人就搞了Logback。</li></ul></li><li><p>◆Logback概述</p><ul><li><p>Logback日志框架</p><ul><li>●Logback是由log4j创始人设计的另一个开源日志组件，性能比log4j要好</li><li>●Logback:是基于slf4j的日志规范实现的框架。</li></ul></li><li><p>Logback主要分为三个技术模块：</p><ul><li>logback-core:logback-core模块为其他两个模块奠定了基础，必须有。</li><li>●logback-classic:它是log4j的一个改良版本，同时它完整实现了slf4jAPI。</li><li>logback-access模块与Tomcat和」etty等Servlet容器集成，以提供HTTP访问日志功能</li></ul></li><li><p>1.使用Logback需要使用哪几个模块，各自的作用是什么。</p><ul><li>●slf4j-api:日志规范</li><li>logback-core:基础模块。</li><li>logback-classic:它是log4j的一个改良版本，同时它完整实现了slf4纠jAPI</li></ul></li></ul></li><li><p>◆Logback快速入门</p><ul><li><p>使用Logback的开发步骤是怎么样的？</p><ul><li>①：在项目下新建文件夹lib,导入Logback的相关jar包到该文件夹下，并添加到项目库中去。</li><li>②：必须将Logback的核心配置文件logback,xml直接拷贝到src目录下。</li></ul></li></ul></li><li><p>◆Logbacki配置详解-输出位置、格式设置</p><ul><li><p>Logback日志系统的特性都是通过核心配置文件logback.Xml控制的。</p></li><li><p>Logback日志输出位置、格式设置：</p><ul><li>●通过logback.xml中的<append>标签可以设置输出位置和日志信息的详细格式。</append></li><li>通常可以设置2个日志输出位置：一个是控制台、一个是系统文件中</li></ul></li></ul></li><li><p>◆Logback配置详解-日志级别设置</p><ul><li><p>日志级别</p><ul><li>级别程度依次是：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR;默认级别是debug(忽路大小写)，对应其方法。</li><li>作用：用于控制系统中哪些日志级别是可以输出的，只输出级别不低于设定级别的日志信息。</li><li>ALL和OFF分别是打开全部日志信息，及关闭全部日志信息。</li></ul></li><li><p>具体在&lt;root level:=”INFO”&gt;标签的level属性中设置日志级别。</p></li><li><p>1、设置日志输出级别的作用是什么？</p><ul><li>●用于控制系统中哪些日志级别是可以输出的。</li></ul></li><li><p>2、Logback的日志级别是什么样的？</p><ul><li>级别程度依次是：TRACE&lt;DEBUG&lt;INFO&lt;WARN&lt;ERROR</li><li>●默认级别是dbug(忽略大小写)，只输出不低于当前级别的日志</li><li>●ALL和OFF分别是打开全部日志和关闭全部日志</li></ul></li></ul></li></ul><h3 id="阶段项目实战"><a href="#阶段项目实战" class="headerlink" title="阶段项目实战"></a>阶段项目实战</h3><ul><li>电影购票系统简介、项目功能演示</li><li>日志框架搭建、系统角色分析</li><li>首页设计、登录、商家界面、用户界面实现</li><li>商家-详情页设计、影片上架、退出</li><li>商家-影片下架、影片修改</li><li>用户-展示全部影片</li><li>用户-购票功能</li><li>用户评分功能</li><li>用户评分降序展示（学生作业）</li><li>用户-根据片名查询全部影片信息（学生作业）</li></ul><h2 id="File、方法递归、IO流"><a href="#File、方法递归、IO流" class="headerlink" title="File、方法递归、IO流"></a>File、方法递归、IO流</h2><h3 id="学习思路"><a href="#学习思路" class="headerlink" title="学习思路"></a>学习思路</h3><ul><li><p>File类使用</p><ul><li>能够使用File的对象操作文件，如：删除、获取文件信息、创建文件夹等</li></ul></li><li><p>方法递归</p><ul><li>理解递归算法思想并能完成常见递归题目以及文件搜索</li></ul></li><li><p>字符集</p><ul><li>程序中经常要读取文件中的数据，程序员必须先知道数据的底层形式才能够去学习如何读写数据</li></ul></li><li><p>IO流的作用、分类</p><ul><li>能够使用1O流完成文件数据的读写等操作</li></ul></li><li><p>字节流、字符流</p><ul><li>数据的类型很多，要学会选择不同的流进行读写操作</li></ul></li></ul><h3 id="File类概述"><a href="#File类概述" class="headerlink" title="File类概述"></a>File类概述</h3><ul><li>File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹）。</li><li>File类提供了诸如：定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能。</li><li></li><li>File对象可以定位文件和文件夹</li><li>Fil封装的对象仅仅是一个路径名，这个路径可以是存在的，也可以是不存在的。</li><li>File创建对象，支持绝对路径支得相对路径（重点）</li></ul><h3 id="File类的常用API"><a href="#File类的常用API" class="headerlink" title="File类的常用API"></a>File类的常用API</h3><ul><li><p>判断文件类型、获取文件信息</p><ul><li><p>public boolean isDirectory()</p><ul><li>测试此抽象路径名表示的Fi1e是否为文件夹</li></ul></li><li><p>public boolean isFile()</p><ul><li>测试此抽象路径名表示的File是否为文件</li></ul></li><li><p>public boolean exists()</p><ul><li>测试此抽象路径名表示的File是否存在</li></ul></li><li><p>public String getAbsolutePath()</p><ul><li>返回此抽象路径名的绝对路径名字符串</li></ul></li><li><p>public String getPath()</p><ul><li>将此抽象路径名转换为路径名字符串</li></ul></li><li><p>public String getName()</p><ul><li>返回由此抽象路径名表示的文件或文件夹的名称</li></ul></li><li><p>public long lastModified()</p><ul><li>返回文件最后修改的时间毫秒值</li></ul></li></ul></li><li><p>创建文件、删除文件功能</p><ul><li><p>File类创建文件的功能</p><ul><li><p>public boolean createNewFile()</p><ul><li>创建一个新的空的文件</li></ul></li><li><p>public boolean mkdir()</p><ul><li>只能创建一级文件夹</li></ul></li><li><p>public boolean mkdirs()</p><ul><li>可以创建多级文件夹</li></ul></li></ul></li><li><p>File类删除文件的功能</p><ul><li><p>public boolean delete()</p><ul><li>删除由此抽像路径名表示的文件或空文件夹</li></ul></li><li><p>delete方法直接删除不走回收站；如果删除的是一个文件，且文件没有被占用则直接删除。只能删除文件和空文件夹</p></li></ul></li></ul></li><li><p>遍历文件夹</p><ul><li><p>public String[] list()</p><ul><li>获取当前目录下所有的”一级文件名称”到一个字符串数组中去返回。</li></ul></li><li><p>public File[] listFi1es()(常用)</p><ul><li>获取当前目录下所有的”一级文件对象”到一个文件对象数组中去返回（重点）</li></ul></li><li><p>ListFiles方法注意事项：</p><ul><li>当调用者不存在时，返回null</li><li>当调用者是一个文件时，返回nul</li><li>当调用者是一个空文件夹时，返回一个长度为0的数组</li><li>当调用者是一个有内容的文件夹时，将里面所有文件和文件夹的路径放在File数组中</li><li>当调用者是一个有隐藏文件的文件夹时，将里面所有文件和文件夹的路径放在File数组中返回，包含隐藏内容</li></ul></li></ul></li></ul><h3 id="方法递归"><a href="#方法递归" class="headerlink" title="方法递归"></a>方法递归</h3><ul><li><p>递归的形式和特点</p><ul><li><p>什么是方法递归？</p><ul><li>方法直接调用自己或者间接调用自己的形式称为方法递归(recursion)。</li><li>递归做为一种算法在程序设计语言中广泛应用。</li></ul></li><li><p>递归的形式</p><ul><li>直接递归：方法自己调用自己。</li><li>间接递归：方法调用其他方法，其他方法又回调方法自己。</li></ul></li><li><p>方法递归存在的问题？</p><ul><li>●递归如果没有控制好终止，会出现递归死循环，导致栈内存溢出现象。</li></ul></li></ul></li><li><p>递归的算法流程、核心要素</p><ul><li><p>递归算法三要素大体可以总结为：</p><ul><li>递归的公式：f(n)=f(n-1)*n;</li><li>递归的终结点：f(1)</li><li>递归的方向必须走向终结点：</li></ul></li></ul></li><li><p>非规律化递归案例-文件搜索</p></li><li><p>非规律化递归案例-啤酒问题</p></li></ul><h3 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h3><ul><li><p>字符集</p><ul><li><p>常见字符集介绍</p><ul><li><p>基础知识</p><ul><li>计算机底层不可以直接存储字符的。计算机中底层只能存储二进制(0、1)</li><li>二进制是可以转换成十进制的</li><li>结论：计算机底层可以表示十进制编号。计算机可以给人类字符进行编号存储，这套编号规则就是字符集。</li></ul></li><li><p>常见字符集</p><ul><li><p>ASCII字符集</p><ul><li>ASCII使用1个字节存储一个字符，一个字节是8位</li></ul></li><li><p>GBK</p><ul><li>GBK是中国的码表，一个中文以两个字节的形式存储</li></ul></li><li><p>Unicode码表</p><ul><li>(又称统一码、万国码、单一码)是计算机科学领域里的一项业界字符编码标准。</li><li>容纳世界上大多数国家的所有常见文字和符号。</li><li>由于Unicode会先通过UTF-8,UTF-16,以及UTF-32的编码成二进制后再存储到计算机，其中最为常见的就是UTF-8。</li></ul></li><li><p>注意</p><ul><li>Unicode是万国码，以UTF-8编码后一个中文一般以三个字节的形式存储。</li><li>UTF-8也要兼容ASCII编码表，</li><li>·技术人员都应该使用UTF-8的字符集编码。</li></ul></li><li><p>编码前和编码后的字符集需要一致，否则会出现中文乱码。</p></li><li></li></ul></li><li><p>1.字符串常见的字符底层组成是什么样的？</p><ul><li>英文和数字等在任何国家的字符集中都占1个字节</li><li>●GBK字符中一个中文字符占2个字节</li><li>●UTF-8编码中一个中文1般占3个字节</li></ul></li><li><p>2.编码前的字符集和编码好的字符集有什么要求？</p><ul><li>●必须一致，否则会出现中文字符乱码</li><li>英文和数字在任何国家的编码中都不会乱码</li></ul></li></ul></li><li><p>字符集的编码、解码操作</p><ul><li></li></ul></li></ul></li><li><p>I0流概述</p><ul><li><p>l表示intput,是数据从硬盘文件读入到内存的过程，称之输入，负责读。</p></li><li><p>O表示output,是内存程序的数据从内存到写出到硬盘文件的过程，称之输出，负责写。</p></li><li><p>IO流 分类</p><h2 id="-7"><a href="#-7" class="headerlink" title="  - "></a>  - </h2></li><li><p>●字节输入流：以内存为基准，来自磁盘文件/网络中的数据以字节的形式读入到内存中去的流称为字节输入流，。</p></li><li><p>·字节输出流：以内存为基准，把内存中的数据以字节写出到磁盘文件或者网络中去的流称为字节输出流，</p></li><li><p>·字符输入流：以内存为基准，来自磁盘文件/网络中的数据以字符的形式读入到内存中去的流称为字符输入流。</p></li><li><p>·字符输出流：以内存为基准，把内存中的数据以字符写出到磁盘文件或者网络介质中去的流称为字符输出流。</p></li></ul></li><li><p>字节流的使用</p><ul><li><p>文件字节输入流：每次读取一个字节</p><ul><li><p>文件字节输入流：FilelnputStream</p></li><li><p>●作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</p></li><li><p>每次读取一个字节存在什么问题？</p><ul><li>性能较慢</li><li>读取中文字符输出无法避免乱码问题。</li></ul></li></ul></li><li><p>文件字节输入流：每次读取一个字节数组</p><ul><li><p>文件字节输入流：FilelnputStream</p></li><li><p>●作用：以内存为基准，把磁盘文件中的数据以字节的形式读取到内存中去。</p></li><li><p>每次读取一个字节数组存在什么问题？</p><ul><li>读取的性能得到了提升</li><li>读取中文字符输出无法避免乱码问题。</li></ul></li></ul></li><li><p>文件字节输入流：一次读完全部字节</p><ul><li><p>1、如何使用字节输入流读取中文内容输出不乱码呢？</p><ul><li>●定义一个与文件一样大的字节数组，一次性读取完文件的全部字节。</li></ul></li><li><p>2、直接把文件数据全部读取到一个字节数组可以避免乱码，是否存在问题？</p><ul><li>●如果文件过大，字节数组可能引起内存溢出。</li></ul></li></ul></li><li><p>文件字节输出流：写字节数据到文件</p></li><li><p>文件拷贝</p></li></ul></li><li><p>资源释放的方式</p><ul><li><p>try-catch-finally</p><ul><li>finally:在异常处理时提供finally块来执行所有清除操作，比如说IO流中的释放资源</li><li>特点：被finally控制的语句最终一定会执行，除非JVM退出</li><li>异常处理标准格式：try..catch..finally</li><li>●finally代码块是最终一定要执行的，可以在代码执行完毕的最后用于释放资源。</li></ul></li><li><p>try-with-resource</p><ul><li><p>什么是资源呢？</p><ul><li>资源都是实现了Closeable/AutoCloseable接口的类对象</li></ul></li></ul></li></ul></li><li><p>字符流的使用</p><ul><li><p>文件字符输入流一次读取一个字符</p><ul><li>文件字符输入流：Reader</li><li>●作用：以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。</li></ul></li><li><p>文件字符输入流~一次读取一个字符数组</p><ul><li>文件字符输入流：FileReader</li><li>·作用：以内存为基准，把磁盘文件中的数据以字符的形式读取到内存中去。</li></ul></li><li><p>文件字符输出流</p><ul><li>文件字符输出流：FileWriter</li><li>·作用：以内存为基准，把内存中的数据以字符的形式写出到磁盘文件中去的流。</li></ul></li><li><p>字节流、字符流如何选择使用？</p><ul><li>字节流适合做一切文件数据的拷贝（音视频，文本）</li><li>字节流不适合读取中文内容输出</li><li>字符流适合做文本文件的操作（读，写）</li></ul></li></ul></li><li><p>缓冲流</p><ul><li><p>缓冲流概述</p><ul><li><p>缓冲流也称为高效流、或者高级流。之前学习的字节流可以称为原始流。</p></li><li><p>·作用：缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</p></li><li></li><li><p>1.缓冲流的作用？</p><ul><li>·缓冲流自带缓冲区、可以提高原始字节流、字符流读写数据的性能</li></ul></li><li><p>2.缓冲流有几种？</p><ul><li><p>字节缓冲流</p><ul><li>字节缓冲输入流：BufferedInputStream</li><li>字节缓冲输出流：BufferedOutputStream</li></ul></li><li><p>字符缓冲流</p><ul><li>字符缓冲输入流：BufferedReader</li><li>字符缓冲输出流：BufferedWriter</li></ul></li></ul></li></ul></li><li><p>字节缓冲流</p><ul><li><p>字节缓冲流性能优化原理：</p><ul><li>·字节缓冲输入流自带了8KB缓冲池，以后我们直接从缓冲池读取数据，所以性能较好。</li><li>·字节缓冲输出流自带了8KB缓冲池，数据就直接写入到缓冲池中去，写数据性能极高了。</li></ul></li><li><p>字节缓冲流</p><ul><li>字节缓冲输入流：BufferedInputStream,提高字节输入流读取数据的性能，读写功能上并无变化。</li><li>字节缓冲输出流：BufferedOutputStream,提高字节输出流读取数据的性能，读写功能上并无变化。</li></ul></li></ul></li><li><p>字节缓冲流的性能分析</p></li><li><p>字符缓冲流</p><ul><li><p>字符缓冲输入流</p><ul><li>●字符缓冲输入流：BufferedReader。</li><li>作用：提高字符输入流读取数据的性能，除此之外多了按照行读取数据的功能。</li></ul></li><li><p>字符缓冲输出流</p><ul><li>,字符缓冲输出流：BufferedWriter。.</li><li>作用：提高字符输出流写取数据的性能，除此之外多了换行功能</li></ul></li><li><p>1.字符缓冲流为什么提高了操作数据的性能？</p><ul><li>字符缓冲流自带8K缓冲区</li><li>可以提高原始字符流读写数据的性能</li></ul></li><li><p>2.字符缓冲流的功能如何使用？</p><ul><li>public BufferedReader(Reader r)</li><li>性能提升了，多了readLine()按照行读取的功能</li><li>public BufferedWriter(Writer w)</li><li>性能提升了，多了newLine()换行的功能</li></ul></li></ul></li></ul></li><li><p>转换流</p><ul><li><p>◆问题引出：不同编码读取乱码问题</p><ul><li>1.字符流直接读取文本内容。</li><li>●必须文件和代码编码一致才不会乱码</li><li>●如果文件和代码编码不一致，读取将出现乱码。</li></ul></li><li><p>◆字符输入转换流</p><ul><li>l.字符输入转换流InputStreamReader作用：</li><li>可以解决字符流读取不同编码乱码的问题</li><li>public InputStreamReader(InputStream is,String charset):</li><li>可以指定编码把原始字节流转换成字符流，如此字符流中的字符不乱码。</li></ul></li><li><p>◆字符输出转换流</p><ul><li>1.字符输出转换流OutputStreamWriter的作用？</li><li>public OutputstreamWriter(Outputstream os,String charset)</li><li>●可以指定编码把字节输出流转换成字符输出流，从而可以指定写出去的字符编码！</li></ul></li><li></li></ul></li><li><p>序列化对象</p><ul><li><p>◆对象序列化</p><ul><li><p>作用：以内存为基准，把内存中的对象存储到磁盘文件中去，称为对象序列化。</p></li><li><p>使用到的流是对象字节输出流：ObjectOutputStream</p></li><li><p>对象如果要序列化，必领实现Serializable序列化接口，</p></li><li><p>1.对象序列化的含义是什么？</p><ul><li>●把对象数据存入到文件中去。</li></ul></li><li><p>2.对象序列化用到了哪个流？</p><ul><li>●对象字节输出流objectOutputstram</li><li>public void writeobject(object obj)</li></ul></li><li><p>3.序列化对象的要求是怎么样的？</p><ul><li>●对象必须实现序列化接口</li></ul></li><li><p>子主题 7</p></li></ul></li><li><p>◆对象反序列化</p><ul><li><p>●使用到的流是对象字节输入流：ObjectInputStream</p></li><li><p>·作用：以内存为基准，把存储到磁盘文件中去的对象数据恢复成内存中的对象，称为对象反序列化。</p></li><li><p>transient 修饰的成员变量不参与序列化</p></li><li><p>对象如果要序列化，必领实现Serializable序列化接口，</p></li><li><p>private static final long serialVersionUID = 1;</p><ul><li>申明序列化的版本号</li><li>序列化的版本号与反序列化的版本号必须一致才不会出错</li></ul></li><li><p>1.对象反序列化的含义是什么？</p><ul><li>●把磁盘中的对象数据恢复到内存的]ava对象中。</li></ul></li><li><p>2.对象反序列化用到了哪个流？</p><ul><li>●对象字节输入流ObjectInputstram</li><li>public Object readobject()</li></ul></li><li><p>子主题 8</p></li></ul></li><li></li></ul></li><li><p>打印流</p><ul><li><p>Printstream,PrintWriter</p><ul><li><p>·作用：打印流可以实现方便、高效的打印数据到文件中去。打印流一般是指：PrintStream,PrintWriteri两个类。</p></li><li><p>●可以实现打印什么数据就是什么数据，例如打印整数97写出去就是97，打印boolean的true,写出去就是true。</p></li><li></li><li><p>1.打印流有几种？各有什么特点？</p><ul><li>●打印流一般是指：PrintStream,PrintWriteri两个类。</li><li>●打印功能2者是一样的使用方式</li><li>PrintStream继承自字节输出流OutputStream,支持写字节</li><li>●PrintWrite:继承自字符输出流Writer,支持写字符</li></ul></li><li><p>2.打印流的优势是什么？</p><ul><li>●两者在打印功能上都是使用方便，性能高效（核心优势）</li></ul></li></ul></li><li><p>输出语句的重定向</p><ul><li>属于打印流的一种应用，可以把输出语句的打印位置改到文件。</li></ul></li></ul></li><li><p>Properties</p><p>  - </p><ul><li><p>Properties属性集对象</p><ul><li>●其实就是一个Map集合，但是我们一般不会当集合使用，因为HashMap更好用。</li></ul></li><li><p>Properties核心作用：</p><ul><li>●Properties代表的是一个属性文件，可以把自己对象中的键值对信息存入到一个属性文件中去。</li><li>属性文件：后缀是.properties结尾的文件，里面的内容都是key=value,后续做系统配置信息的。</li></ul></li><li><p>1.Properties的作用？</p><ul><li>void store(Writer writer,String comments)</li><li>●可以存储Properties属性集的键值对数据到属性文件中去：</li><li>void load(Reader reader)</li><li>●可以加载属性文件中的数据到Properties.对象中来：</li></ul></li></ul></li><li><p>IO框架</p><ul><li><p>commons-io概述</p><ul><li>commons-io是apache开源基金组织提供的一组有关IO操作的类库，可以提高IO功能开发的效率。</li><li>●commons-io工具包提供了很多有关io操作的类。有两个主要的类FileUtils,1 DUtils</li></ul></li></ul></li></ul><h2 id="多线程"><a href="#多线程" class="headerlink" title="多线程"></a>多线程</h2><h3 id="多线程-1"><a href="#多线程-1" class="headerlink" title="多线程"></a>多线程</h3><ul><li><p>什么是线程？</p><ul><li>线程(thread)是一个程序内部的一条执行路径。</li><li>我们之前启动程序执行后，main方法的执行其实就是一条单独的执行路径。</li><li>程序中如果只有一条执行路径，那么这个程序就是单线程的程序。</li></ul></li><li><p>多线程是什么？</p><ul><li>多线程是指从软硬件上实现多条执行流程的技术。</li></ul></li></ul><h3 id="多线程的创建"><a href="#多线程的创建" class="headerlink" title="多线程的创建"></a>多线程的创建</h3><ul><li><p>◆方式一：继承Thread类</p><ul><li><p>Thread类</p><ul><li>Java是通过java.lang.Thread类来代表线程的.</li><li>按照面向对象的思想，Thread类应该提供了实现多线程的方式。</li></ul></li><li><p>实现方案</p><ul><li>①定义一个子类MyThread:继承线程类java.lang.Thread,重写run方法</li><li>②创建MyThread类的对象</li><li>③调用线程对象的start()方法启动线程（启动后还是执行run方法的)</li></ul></li><li><p>优缺点</p><ul><li>●优点：编码简单</li><li>●缺点：线程类已经继承Thread,无法继承其他类，不利于扩展。</li></ul></li><li><p>1、为什么不直接调用了run方法，而是调用start启动线程。</p><ul><li>●直接调用ru方法会当成普通方法执行，此时相当于还是单线程执行。</li><li>●只有调用start方法才是启动一个新的线程执行。</li></ul></li><li><p>2、把主线程任务放在子线程之前了。</p><ul><li>●这样主线程一直是先跑完的，相当于是一个单线程的效果了。</li></ul></li><li><p>1.方式一是如何实现多线程的？</p><ul><li>继承Thread类</li><li>重写run方法</li><li>创建线程对象</li><li>调用start()方法启动。</li></ul></li><li><p>2.优缺点是什么？</p><ul><li>●优点：编码简单</li><li>●缺点：存在单继承的局限性，线程类继承Thread后，不能继承其他类，不便于扩展。</li></ul></li></ul></li><li><p>◆方式二：实现Runnable接口</p><ul><li><p>实现Runnable接口</p><ul><li><p>实现方案</p><ul><li>定义一个线程任务类MyRunnable实现Runnable接口，重写run(）方法</li><li>创建MyRunnable任务对象</li><li>把MyRunnable任务对象交给Thread处理。</li><li>调用线程对象的start()方法启动线程</li></ul></li><li><p>优缺点</p><ul><li>●优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</li><li>●缺点：编程多一层对象包装，如果线程有执行结果是不可以直接返回的。</li></ul></li><li><p>1.第二种方式是如何创建线程的？</p><ul><li>●定义一个线程任务类MyRunnable实现Runnable接▣，重写run(）方法</li><li>·创建MyRunnable对象</li><li>●把MyRunnable任务对象交给Thread线程对象处理。</li><li>●调用线程对象的start(0方法启动线程</li></ul></li><li><p>2.第二种方式的优点</p><ul><li>●优点：线程任务类只是实现了Runnale接口，可以继续继承和实现。</li><li>●缺点：如果线程有执行结果是不能直接返回的。</li></ul></li></ul></li><li><p>匿名内部类形式</p><ul><li><p>实现方案</p><ul><li>可以创建Runnable的匿名内部类对象。</li><li>交给Thread处理。</li><li>调用线程对象的start()启动线程。</li></ul></li></ul></li></ul></li><li><p>◆方式三：JDK5.0新增：实现Callable接口</p><ul><li><p>前2种线程创建方式</p><ul><li><p>1、前2种线程创建方式都存在一个问题：</p><ul><li>●他们重写的run方法均不能直接返回结果。</li><li>●不适合需要返回线程执行结果的业务场景。</li></ul></li><li><p>2、怎么解决这个问题呢？</p><ul><li>●JDK5.0提供了Callable和FutureTask来实现。</li></ul></li></ul></li><li><p>实现方案</p><ul><li><p>①、得到任务对象</p><ul><li>1.定义类实现Callable接口，重写call方法，封装要做的事情。</li><li>2.用FutureTask把Callable对象封装成线程任务对象。</li></ul></li><li><p>2)、把线程任务对象交给Thread处理。</p></li><li><p>3)、调用Thread的start方法启动线程，执行任务</p></li><li><p>④、线程执行完毕后、通过FutureTask的get方法去获取任务执行的结果。</p></li></ul></li><li><p>优缺点</p><ul><li>●优点：线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。</li><li>可以在线程执行完毕后去获取线程执行的结果。</li><li>●缺点：编码复杂一点。</li></ul></li></ul></li><li></li></ul><h3 id="Thread的常用方法"><a href="#Thread的常用方法" class="headerlink" title="Thread的常用方法"></a>Thread的常用方法</h3><ul><li><p>Thread常用API说明</p><ul><li>●Thread常用方法：获取线程名称getName()、设置名称setName()、获取当前线程对象currentThread()。</li><li>●至于Thread类提供的诸如：yield、join、interrupt、不推荐的方法stop、守护线程、线程优先级等线程的控制方法，在开发中很少使用，这些方法会在高级篇以及后续需要用到的时候再为大家讲解。</li></ul></li><li><p>1.当有很多线程在执行的时候，我们怎么去区分这些线程呢？</p><ul><li>此时需要使用Thread的常用方法：getName()、setName()、currentThread()等。</li></ul></li><li><ul><li></li></ul></li></ul><h3 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h3><ul><li><p>线程安全问题是什么、发生的原因</p><ul><li><p>线程安全问题</p><ul><li>·多个线程同时操作同一个共享资源的时候可能会出现业务安全问题，称为线程安全问题。</li></ul></li><li><p>1.线程安全问题出现的原因？</p><ul><li>存在多线程并发</li><li>同时访问共享资源</li><li>存在修改共享资源</li></ul></li></ul></li><li><p>线程安全问题案例模拟</p><ul><li>1.线程安全问题发生的原因是什么？</li><li>●多个线程同时访问同一个共享资源且存在修改该资源。</li></ul></li></ul><h3 id="线程同步"><a href="#线程同步" class="headerlink" title="线程同步"></a>线程同步</h3><ul><li><p>◆同步思想概述</p><ul><li><p>为了解决线程安全问题。</p><ul><li><p>1、取钱案例出现问题的原因？</p><ul><li>●多个线程同时执行，发现账户都是够钱的。</li></ul></li><li><p>2、如何才能保证线程安全呢？</p><ul><li>●让多个线程实现先后依次访问共享资源，这样就解决了安全问题</li></ul></li></ul></li><li><p>线程同步的核心思想</p><ul><li>加锁，把共享资源进行上锁，每次只能一个线程进入访问完毕以后解锁，然后其他线程才能进来。</li></ul></li></ul></li><li><p>◆方式一：同步代码块</p><ul><li><p>同步代码块</p><ul><li>●作用：把出现线程安全问题的核心代码给上锁。</li><li>·原理：每次只能一个线程进入，执行完毕后自动解锁，其他线程才可以进来执行。</li></ul></li><li><p>锁对象要求</p><ul><li>●理论上：锁对象只要对于当前同时执行的线程来说是同一个对象即可。</li></ul></li><li><p>synchronized (this){     }</p></li><li><p>锁对象用任意唯一的对象好不好呢？</p><ul><li>●不好，会影响其他无关线程的执行。</li></ul></li><li><p>锁对象的规范要求</p><ul><li>·规范上：建议使用共享资源作为锁对象。</li><li>·对于实例方法建议使用this作为锁对象。</li><li>·对于静态方法建议使用字节码（类名.class)对象作为锁对象。</li></ul></li><li><p>1.同步代码块是如何实现线程安全的？</p><ul><li>●对出现问题的核心代码使用synchronized进行加锁</li><li>●每次只能一个线程占锁进入访问</li></ul></li><li><p>2.同步代码块的同步锁对象有什么要求？</p><ul><li>●对于实例方法建议使用this作为锁对象。</li><li>●对于静态方法建议使用字节码（类名.clas5)对象作为锁对象。</li></ul></li></ul></li><li><p>◆方式二：同步方法</p><ul><li><p>同步方法</p><ul><li>●作用：把出现线程安全问题的核心方法给上锁。</li><li>·原理：每次只能一个线程进入，执行完毕以后自动解锁，其他线程才可以进来执行。</li></ul></li><li><p>同步方法底层原理</p><ul><li>●同步方法其实底层也是有隐式锁对象的，只是锁的范围是整个方法代码。</li><li>●如果方法是实例方法：同步方法默认用thS作为的锁对象。但是代码要高度面向对象！</li><li>●如果方法是静态方法：同步方法默认用类名.clSS作为的锁对象。</li></ul></li><li><p>1、是同步代码块好还是同步方法好一点？</p><ul><li>●同步代码块锁的范围更小，同步方法锁的范围更大。</li></ul></li><li><p>1.同步方法是如何保证线程安全的？</p><ul><li>●对出现问题的核心方法使用synchronized修饰</li><li>·每次只能一个线程占锁进入访问</li></ul></li><li><p>2.同步方法的同步锁对象的原理？</p><ul><li>·对于实例方法默认使用ths作为锁对象。</li><li>●对于静态方法默认使用类名.class对象作为锁对象。</li></ul></li></ul></li><li><p>方式三：Lock锁</p><ul><li><p>Lock锁</p><ul><li>·为了更清晰的表达如何加锁和释放锁，JDK5以后提供了一个新的锁对像Lock,更加灵活、方便，</li><li>●Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。</li><li>●Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来构建Lock锁对象。</li></ul></li></ul></li></ul><h3 id="线程通信"><a href="#线程通信" class="headerlink" title="线程通信"></a>线程通信</h3><ul><li><p>什么是线程通信、如何实现？</p><ul><li>·所谓线程通信就是线程间相互发送数据，线程通信通常通过共享一个数据的方式实现。</li><li>·线程间会根据共享数据的情况决定自己该怎么做，以及通知其他线程怎么做。</li></ul></li><li><p>线程通信常见模型</p><ul><li>●生产者与消费者模型：生产者线程负责生产数据，消费者线程负责消费数据。</li><li>要求：生产者线程生产完数据后，唤醒消费者，然后等待自己；消费者消费完该数据后，唤醒生产者，然后等待自己。</li></ul></li><li><p>·线程通信的前提：线程通信通常是在多个线程操作同一个共享资源的时候需要进行通信，且要保证线程安全。</p><ul><li></li></ul></li></ul><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><ul><li><p>线程池概述</p><ul><li><p>什么是线程池？</p><ul><li>·线程池就是一个可以复用线程的技术。</li></ul></li><li><p>不使用线程池的问题</p><ul><li>●如果用户每发起一个请求，后台就创建一个新线程来处理，下次新任务来了又要创建新线程，而创建新线程的开销是很大的，这样会严重影响系统的性能。</li></ul></li></ul></li><li><p>线程池实现的API、参数说明</p><ul><li><p>谁代表线程池？</p><ul><li>JDK5.0起提供了代表线程池的接口：ExecutorService</li></ul></li><li><p>如何得到线程池对象</p><ul><li>●方式一：使用ExecutorServicel的实现类ThreadPoolExecutor自创建一个线程池对象</li><li>●方式二：使用Executors(线程池的工具类)调用方法返回不同特点的线程池对象</li></ul></li><li><p>ThreadPoolExecutor构造器的参数说明</p><ul><li><p>参数一：指定线程池的线程数量（核心线程）：corePoolSize</p><ul><li>不能小于0</li></ul></li><li><p>参数二：指定线程池可支持的最大线程数 maximumPoolSize</p><ul><li>最大数量&gt;=核心线程数量</li></ul></li><li><p>参数三：指定临时线程的最大存活时间：keepAliveTime</p><ul><li>不能小于0</li></ul></li><li><p>参数四：指定存活时间的单位（秒、分、时、天）unit</p><ul><li>时间单位</li></ul></li><li><p>参数五：指定任务队列：workQueue     不能为null</p></li><li><p>参数六：指定用哪个线程工厂创建线程：  threadFactory  不能为null</p></li><li><p>参数七：指定线程忙，任务满的时候，新任务来了怎么办：handler   不能为null</p></li></ul></li><li><p>线程池常见面试题</p><ul><li><p>临时线程什么时候创建啊？</p><ul><li>·新任务提交时发现核心线程都在忙，任务队列也满了，并且还可以创建临时线程，此时才会创建临时线程。</li></ul></li><li><p>什么时候会开始拒绝任务？</p><ul><li>核心线程和临时线程都在忙，任务队列也满了，新的任务过来的时候才会开始任务拒绝。</li></ul></li></ul></li><li><p>1.谁代表线程池？</p><ul><li>●ExecutorService接▣</li></ul></li><li><p>2.ThreadPoolExecutor实现线程池对象的七个参数是什么意思</p><ul><li>●使用线程池的实现类ThreadPoolExecutor</li></ul></li></ul></li><li><p>线程池处理Runnable任务</p></li><li><p>线程池处理Callable任务</p><ul><li><p>1.线程池如何处理Callable任务，并得到任务执行完后返回的结果。</p><ul><li>●使用ExecutorService的方法：</li><li>Future<t>submit(Callable<t>command)</t></t></li></ul></li></ul></li><li><p>Executors工具类实现线程池</p><ul><li><p>Executors得到线程池对象的常用方法</p><ul><li>Executors:线程池的工具类通过调用方法返回不同类型的线程池对象。</li><li>注意：Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象的。</li></ul></li><li><p>Executors使用可能存在的陷阱</p><ul><li>●大型并发系统环境中使用Executors如果不注意可能会出现系统风险，</li></ul></li><li><p>1.Executors.工具类底层是基于什么方式实现的线程池对象？</p><ul><li>线程池ExecutorService的实现类：ThreadPoolExecutor</li></ul></li><li><p>2.Executors是香适合做大型互联网场景的线程池方案？</p><ul><li>不合适。</li><li>●建议使用ThreadPoolExecutor来指定线程池参数，这样可以明确线程池的运行规则,规避资源耗尽的风险。</li></ul></li></ul></li></ul><h3 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h3><ul><li><p>定时器</p><ul><li>·作用：闹钟、定时邮件发送。</li><li>·定时器是一种控制任务延时调用，或者周期调用的技术。</li></ul></li><li><p>定时器的实现方式</p><ul><li><p>●方式一：Timer</p><ul><li><p>Timer定时器的特点和存在的问题</p><ul><li>1,Tmer是单线程，处理多个任务按照顺序执行，存在延时与设置定时器的时间有出入。</li><li>2、可能因为其中的某个任务的异常使Tmr线程死掉，从而影响后续任务执行，</li></ul></li></ul></li><li><p>●方式二：ScheduledExecutorService</p><ul><li><p>ScheduledExecutorService定时器</p><ul><li>●ScheduledExecutorService是jdkI.5中引入了并发包，目的是为了弥补Timer的缺陷，ScheduledExecutorService内部为线程池</li></ul></li><li><p>ScheduledExecutorService的优点</p><ul><li>1、基于线程池，某个任务的执行情况不会影响其他定时任务的执行。</li></ul></li></ul></li></ul></li></ul><h3 id="并发并行"><a href="#并发并行" class="headerlink" title="并发并行"></a>并发并行</h3><ul><li><p>并发与并行</p><ul><li>·正在运行的程序（软件）就是一个独立的进程，线程是属于进程的，多个线程其实是并发与并行同时进行的。</li></ul></li><li><p>并发的理解：</p><ul><li>CPU同时处理线程的数量有限。</li><li>CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</li></ul></li><li><p>并行的理解：</p><ul><li>·在同一个时刻上，同时有多个线程在被CPU处理并执行。</li></ul></li><li><p>1.简单说说并发和并行的含义</p><ul><li>●并发：CPU分时轮询的执行线程。</li><li>●并行：同一个时刻同时在执行。</li></ul></li></ul><h3 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h3><ul><li><p>线程的状态</p><ul><li>线程的状态：也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。</li><li>理解线程的状态有利于提升并发编程的理解能力。</li></ul></li><li><p>Java线程的状态</p><ul><li><p>Java总共定义了6种状态</p><h2 id="-8"><a href="#-8" class="headerlink" title="  - "></a>  - </h2></li><li><p>6种状态都定义在Thread类的内部枚举类中。</p></li></ul></li><li><p>线程的六种状态：</p><ul><li>新建状态(NEW)</li><li>就绪状态(RUNNABLE)</li><li>阻寒状态(BLOCKED)</li><li>等待状态(NAITING)</li><li>计时等待(TIMED WAITING)</li><li>结束状态(TERMINATED)</li></ul></li></ul><h2 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h2><h3 id="网络编程-1"><a href="#网络编程-1" class="headerlink" title="网络编程"></a>网络编程</h3><ul><li><p>什么是网络编程？</p><ul><li>·网络编程可以让程序与网络上的其他设备中的程序进行数据交互。</li></ul></li><li><p>网络通信基本模式</p><ul><li><p>●常见的通信模式有如下2种形式：Client-Server(CS)、Browser/Server(BS)</p><ul><li><p>CS</p><ul><li>需要程序员开发实现。</li><li>用户需要安装客户端。</li></ul></li><li><p><strong>BS</strong></p><ul><li>不需要程序员开发实现</li><li>用户需要安装浏览器</li></ul></li></ul></li></ul></li></ul><h3 id="网络通信三要素"><a href="#网络通信三要素" class="headerlink" title="网络通信三要素"></a>网络通信三要素</h3><ul><li><p>三要素概述、要素一：IP地址</p><ul><li><p>实现网络编程关键的三要素</p><ul><li>IP地址：设备在网络中的地址，是唯一的标识。</li><li>端口：应用程序在设备中唯一的标识。</li><li>协议：数据在网络中传输的规则，常见的协议有UDP协议和TCP协议。</li></ul></li><li><p>IP地址</p><ul><li><p>●IP(Internet Protocol):全称”互联网协议地址”，是分配给上网设备的唯一标志。</p></li><li><p>●常见的IP分类为：1Pv4和IPv6</p><ul><li><p>IPv4</p><ul><li>32字节，采用点分十进制表示法</li></ul></li><li><p>IPv6</p><ul><li>128位(16个字节)，号称可以为地球每一粒沙子编号。</li><li>IPV6分成8个整数，每个整数用四个十六进制位表示，数之间用冒号(：)分开。</li></ul></li></ul></li><li><p>IP地址形式：</p><ul><li>公网地址、和私有地址（局域网使用）。</li><li>192.168.开头的就是常见的局域网地址，范围即为192.168.0.0-192.168.255.255，专门为组织机构内部使用。</li></ul></li><li><p>IP常用命令：</p><ul><li>ipconfig:查看本机IP地址</li><li>ping IP地址/域名：检查网络是否连通</li></ul></li><li><p>特殊IP地址：</p><ul><li>●本机IP:127.0.0.1或者localhost:称为回送地址也可称本地回环地址，只会寻找当前所在本机。</li></ul></li></ul></li></ul></li><li><p>IP地址操作类-InetAddress</p><ul><li><p>InetAddress的使用</p><ul><li>此类表示Internet协议(IP)地址。</li></ul></li></ul></li><li><p>要素二：端口号</p><ul><li><p>端口号：标识正在计算机设备上运行的进程（程序），被规定为一个16位的二进制，范围是0~65535。</p></li><li><p>端口类型</p><ul><li>●周知端口：01023，被预先定义的知名应用占用（如：HTTP占用80，FTP占用21）</li><li>●注册端口：1024~49151，分配给用户进程或某些应用程序。（如：Tomcat占用8080，MySQL占用3306)</li><li>动态端口：49152到65535，之所以称为动态端口，是因为它一般不固定分配某种进程，而是动态分配。</li><li>注意：我们自己开发的程序选择注册端口，且一个设备中不能出现两个程序的端口号一样，否则出错。</li></ul></li></ul></li><li><p>要素三：协议</p><ul><li><p>通信协议</p><ul><li>连接和通信数据的规则被称为网络通信协议</li></ul></li><li><p>网络通信协议有两套参考模型</p><ul><li>OSI引参考模型：世界互联协议标准，全球通信规范，由于此模型过于理想化，未能在因特网上进行广泛推广。</li><li>TCP/IP参考模型（或TCP/IP协议）：事实上的国际标准。</li><li></li></ul></li><li><p>传输层的2个常见协议</p><ul><li>TCP:传输控制协议</li><li>UDP:用户数据报协议</li></ul></li><li><p>TCP协议特点</p><ul><li>使用TCP协议，必须双方先建立连接，它是一种面向连接的可靠通信协议。</li><li>传输前，采用“三次握手”方式建立连接，所以是可靠的。</li><li>在连接中可进行大数据量的传输。</li><li>连接、发送数据都需要确认，且传输完毕后，还需释放已建立的连接，通信效率较低。</li></ul></li><li><p>TCP协议通信场景</p><ul><li>对信息安全要求较高的场景，例如：文件下载、金融等数据通信。</li><li>采用三次握手建立连接，四次挥手断开连接</li></ul></li><li><p>UDP协议：</p><ul><li>●UDP是一种无连接、不可靠传输的协议。</li><li>●将数据源P、目的地P和端口封装成数据包，不需要建立连接</li><li>●每个数据包的大小限制在64KB内</li><li>●发送不管对方是否准备好，接收方收到也不确认，故是不可靠的</li><li>●可以广播发送，发送数据结束时无需释放资源，开销小，速度快。</li></ul></li><li><p>UDP协议通信场景</p><ul><li>●语音通话，视频会话等。</li></ul></li><li><p>1、通信协议是什么？</p><ul><li>●计算机网络中，连接和通信数据的规则被称为网络通信协议。</li></ul></li><li><p>2、TCP通信协议的特点是什么样的？</p><ul><li>●它是一种面向连接的可靠通信协议。</li><li>●传输前，采用“三次握手”方式建立连接，点对点的通信，所以可靠。</li><li>●在连接中可进行大数据量的传输。</li><li>●通信效率较低。</li></ul></li><li><p>3、UDP协议的特点是什么</p><ul><li>●用户数据报协议(User Datagram Protocol)</li><li>●UDP是面向无连接，不可靠传输的通信协议。</li><li>●速度快，有大小限制一次最多发送64K,数据不安全，易丢失数据。</li></ul></li></ul></li></ul><h3 id="UDP通信"><a href="#UDP通信" class="headerlink" title="UDP通信"></a>UDP通信</h3><ul><li><p>◆UDP通信：快速入门</p><ul><li><p>UDP协议的特点</p><ul><li>UDP是一种无连接、不可靠传输的协议。</li><li>将数据源IP、目的地P和端口以及数据封装成数据包，大小限制在64KB内，直接发送出去即可。</li></ul></li><li><p>DatagramPacket:数据包对象（韭菜盘子）</p></li><li><p>DatagramSocket:发送端和接收端对象（人）</p></li></ul></li><li><p>◆UDP通信：多发多收（单播）</p><ul><li><p>1.UDP的接收端为什么可以接收很多发送端的消息？</p><ul><li>●接收端只负责接收数据包，无所谓是哪个发送端的数据包</li></ul></li></ul></li></ul><h3 id="UDP通信-广播、组播"><a href="#UDP通信-广播、组播" class="headerlink" title="UDP通信-广播、组播"></a>UDP通信-广播、组播</h3><ul><li><p>UDP的三种通信方式</p><ul><li>单播：单台主机与单台主机之间的通信</li><li>广播：当前主机与所在网络中的所有主机通信。</li><li>组播：当前主机与选定的一组主机的通信。</li></ul></li><li><p>UDP如何实现广播</p><ul><li><p>使用广播地址：255.255.255.255</p></li><li><p>具体操作：</p><ul><li>发送端发送的数据包的目的地写的是广播地址、且指定端口。(255.255.255.255，9999)</li><li>本机所在网段的其他主机的程序只要匹配端口成功即就可以收到消息了。(9999)</li></ul></li></ul></li><li><p>UDP如何实现组播</p><ul><li><p>使用组播地址：224.0.0.0~239.255.255.255</p></li><li><p>具体操作：</p><ul><li>①发送端的数据包的目的地是组播1P(例如：224.0.1.1，端口：9999)</li><li>②接收端必须绑定该组播1P(224.0.1.1),端口还要对应发送端的目的端口9999，这样即可接收该组播消息。</li><li>③DatagramSocket的子类MulticastSocketi可以在接收端绑定组播IP.</li></ul></li></ul></li><li><p>1.如何实现广播，具体怎么操作？</p><ul><li>●发送端目的IP使用广播IP:255.255.255.255 ，9999。</li><li>·所在网段的其他主机对应了端口(9999)即可接收消息</li></ul></li><li><p>2.如何实现组播，具体怎么操作？</p><ul><li>●发送端目的IP使用组播IP,且指定端口。</li><li>●所在网段的其他主机注册了该组播工P和对应端口即可接收消息，</li></ul></li></ul><h3 id="TCP通信-快速入门"><a href="#TCP通信-快速入门" class="headerlink" title="TCP通信-快速入门"></a>TCP通信-快速入门</h3><ul><li><p>TCP协议回顾：</p><ul><li>●TCP是一种面向连接，安全、可靠的传输数据的协议</li><li>●传输前，采用“三次握手”方式，点对点通信，是可靠的</li><li>●在连接中可进行大数据量的传输·</li><li>注意：在java中只要是使用java.net.Socket:类实现通信，底层即是使用了TCP协议</li></ul></li><li><p>◆编写客户端代码</p><ul><li><p>1.TCP通信的客户端的代表类是谁？</p><ul><li>●Socket类</li><li>●public Socket(String host,int port)</li></ul></li><li><p>2.TCP通信如何使用Socket管道发送、接收数据。</p><ul><li>●OutputStream getoutputStream():获得字节输出流对象（发）</li><li>●Inputstream getinputStream():获得字节输入流对象（收）</li></ul></li></ul></li><li><p>◆编写服务端代码、原理分析</p><ul><li><p>1,TCP通信服务端用的代表类？</p><ul><li>●ServerSocket类，注册端▣。</li><li>●调用accept()方法阻塞等待接收客户端连接。得到Socket.对象。</li></ul></li><li><p>2,TCP通信的基本原理？</p><ul><li>●客户端怎么发，服务端就应该怎么收。</li><li>●客户端如果没有消息，服务端会进入阻塞等待。</li><li>●Socket一方关闭或者出现异常、对方Socket也会失效或者出错。</li></ul></li></ul></li></ul><h3 id="TCP通信-多发多收消息"><a href="#TCP通信-多发多收消息" class="headerlink" title="TCP通信-多发多收消息"></a>TCP通信-多发多收消息</h3><ul><li><p>本案例实现了多发多收，那么是否可以同时接收多个客户端的消息？</p><ul><li>·不可以的。</li><li>·因为服务端现在只有一个线程，只能与一个客户端进行通信。</li></ul></li><li><p>1,本次多发多收是如何实现的</p><ul><li>●客户端使用循环反复地发送消息。</li><li>●服务端使用循环反复地接收消息。</li></ul></li><li><p>2.现在服务端为什么不可以同时接收多个客户端的消息。</p><ul><li>●目前服务端是单线程的，每次只能处理一个客户端的消息。</li></ul></li></ul><h3 id="TCP通信-同时接受多个客户端消息"><a href="#TCP通信-同时接受多个客户端消息" class="headerlink" title="TCP通信-同时接受多个客户端消息"></a>TCP通信-同时接受多个客户端消息</h3><ul><li><p>1、之前我们的通信是否可以同时与多个客户端通信，为什么？</p><ul><li>●不可以的</li><li>●单线程每次只能处理一个客户端的Socket通信</li></ul></li><li><p>2、如何才可以让服务端可以处理多个客户端的通信需求？</p><ul><li>●引入多线程。</li></ul></li><li><p>1.本次是如何实现服务端接收多个客户端的消息的。</p><ul><li>●主线程定义了循环负责接收客户端Socket管道连接</li><li>●每接收到一个Socketi通信管道后分配一个独立的线程负责处理它。</li></ul></li></ul><h3 id="TCP通信-使用线程池优化"><a href="#TCP通信-使用线程池优化" class="headerlink" title="TCP通信-使用线程池优化"></a>TCP通信-使用线程池优化</h3><ul><li><p>1.本次使用线程池的优势在哪里？</p><ul><li>●服务端可以复用线程处理多个客户端，可以避免系统瘫痪。</li><li>●适合客户端通信时长较短的场景。</li></ul></li></ul><h3 id="TCP通信实战案例-即时通信"><a href="#TCP通信实战案例-即时通信" class="headerlink" title="TCP通信实战案例-即时通信"></a>TCP通信实战案例-即时通信</h3><ul><li><p>1.即时通信是什么含义，要实现怎么样的设计？</p><ul><li>●即时通信，是指一个客户端的消息发出去，其他客户端可以接收到。</li><li>●之前我们的消息都是发给服务端的。</li><li>●即时通信需要进行端口转发的设计思想。</li></ul></li><li><p>1.即时通信是什么含义，要实现怎么样的设计？</p><ul><li>●即时通信，是指一个客户端的消息发出去，其他客户端可以接收到</li><li>●即时通信需要进行端口转发的设计思想。</li><li>●服务端需要把在线的Socket管道存储起来</li><li>●一旦收到一个消息要推送给其他管道</li></ul></li></ul><h3 id="TCP通信实战案例-实现BS请求"><a href="#TCP通信实战案例-实现BS请求" class="headerlink" title="TCP通信实战案例-实现BS请求"></a>TCP通信实战案例-实现BS请求</h3><ul><li><p>1、之前的客户端都是什么样的</p><ul><li>●其实就是CS架构，客户端实需要我们自己开发实现的。</li></ul></li><li><p>2、BS结构是什么样的，需要开发客户端吗？</p><ul><li>●浏览器访问服务端，不需要开发客户端。</li></ul></li><li><p>注意：服务器必须给浏览器响应HTTP协议格式的数据，否则浏览器不识别。</p></li><li><p>1.TCP通信如何实现BS请求网页信息回来呢？</p><ul><li>●客户端使用浏览器发起请求（不需要开发客户端）</li><li>●服务端必须按照浏览器的协议规则响应数据。</li><li>●浏览器使用什么协议规则呢？</li><li>●HTTP协议（简单了解下）</li></ul></li></ul><h2 id="单元测试、反射、注解、动态代理"><a href="#单元测试、反射、注解、动态代理" class="headerlink" title="单元测试、反射、注解、动态代理"></a>单元测试、反射、注解、动态代理</h2><h3 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h3><ul><li><p>◆单元测试概述</p><ul><li><p>●单元测试就是针对最小的功能单元编写测试代码，Java程序最小的功能单元是方法，因此，单元测试就是针对Java方法的测试，进而检查方法的正确性。</p></li><li><p>目前测试方法是怎么进行的，存在什么问题</p><ul><li>只有一个main方法，如果一个方法的测试失败了，其他方法测试会受到影响。</li><li>无法得到测试的结果报告，需要程序员自己去观察测试是否成功。</li><li>无法实现自动化测试。</li></ul></li><li><p>Junit.单元测试框架</p><ul><li>●JUnit是使用ava语言实现的单元测试框架，它是开源的，Java开发者都应当学习并使用JUnits编写单元测试。</li><li>此外，几乎所有的IDE工具都集成了JUnit,这样我们就可以直接在IDE中编写并运行Unit测试，JUnit目前最新版本是5。</li></ul></li><li><p>JUnit优点</p><ul><li>●JUt可以灵活的选择执行哪些测试方法，可以一键执行全部测试方法。</li><li>●Junit可以生成全部方法的测试报告。</li><li>·单元测试中的某个方法测试失败了，不会影响其他测试方法的测试。</li></ul></li></ul></li><li><p>◆单元测试快速入门</p><ul><li><p>1.JUnit单元测试的实现过程是什么样的</p><ul><li>●必须导入Junit框架的jar包。</li><li>●定义的测试方法必须是无参数无返回值，且公开的方法。</li><li>●测试方法使用@Test注解标记。</li></ul></li><li><p>2.JUnit测试某个方法，测试全部方法怎么处理？成功的标志是什么</p><ul><li>·测试某个方法直接右键该方法启动测试。</li><li>测试全部方法，可以选择类或者模块启动。</li><li>●红色失败，绿色通过。</li></ul></li></ul></li><li><p>◆单元测试常用注解</p><h2 id="-9"><a href="#-9" class="headerlink" title="  - "></a>  - </h2></li></ul><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><ul><li><p>反射概述</p><ul><li><p>概述</p><ul><li>反射是指对于任何一个Clss类，在”运行的时候”都可以直接得到这个类全部成分。</li><li>在运行时，可以直接得到这个类的构造器对象：Constructor</li><li>在运行时，可以直接得到这个类的成员变量对象：Field</li><li>在运行时，可以直接得到这个类的成员方法对象：Method</li><li>这种运行时动态获取类信息以及动态调用类中成分的能力称为Java语言的反射机制。</li></ul></li><li><p>关键</p><ul><li>反射的第一步都是先得到编译后的Class类对象，然后就可以得到Class的全部成分。</li></ul></li><li><p>1.反射的基本作用、关键？</p><ul><li>●反射是在运行时获取类的字节码文件对象：然后可以解析类中的全部成分。</li><li>●反射的核心思想和关键就是：得到编译以后的class文件对象。</li></ul></li></ul></li><li><p>反射获取类对象</p><ul><li><p>Class类中静态方法</p><ul><li>1、forName(String className)</li><li>2、类名.class</li><li>3、对象.getClass0</li></ul></li><li><p>1.反射的第一步是什么？</p><ul><li>●获取Class类对象，如此才可以解析类的全部成分</li></ul></li><li><p>2.获取Class:类的对象的三种方式</p><ul><li>●方式-：Class c1=Class.forName(“全类名”)月</li><li>●方式二：Class c2=类名.class</li><li>●方式三：Class c3=对象.getClass(0;</li></ul></li></ul></li><li><p>反射获取构造器对象</p><ul><li><p>使用反射技术获取构造器对象并使用</p><ul><li>反射的第一步是先得到类对象，然后从类对象中获取类的成分对象。</li><li>●Class类中用于获取构造器的方法</li><li>·获取构造器的作用依然是初始化一个对象返回。</li></ul></li><li><p>1.利用反射技术获取构造器对象的方式</p><ul><li>getDeclaredConstructors()</li><li>getDeclaredConstructor (Class&lt;?&gt;…parameterTypes)</li></ul></li><li><p>2.反射得到的构造器可以做什么？</p><ul><li><p>●依然是创建对象的</p><ul><li>public newlnstance(Object…initargs)</li></ul></li><li><p>●如果是非pubc的构造器，需要打开权限（暴力反射)，然后再创建对象</p><ul><li>setAccessible(boolean)</li><li>■反射可以破坏封装性，私有的也可以执行了。</li></ul></li></ul></li></ul></li><li><p>反射获取成员变量对象</p><ul><li><p>1.利用反射技术获取成员变量的方式</p><ul><li><p>●获取类中成员变量对象的方法</p><ul><li>getDeclaredFields()</li><li>getDeclaredField (String name)</li></ul></li></ul></li><li><p>2.反射得到成员变量可以做什么？</p><ul><li><p>●依然是在某个对象中取值和赋值。</p><ul><li>void set(object obj,Object value):</li><li>Object get(Object obj)</li></ul></li><li><p>●如果某成员变量是非public的，需要打开权限（暴力反射），然后再取值、赋值</p><ul><li>setAccessible(boolean)</li></ul></li></ul></li></ul></li><li><p>反射获取方法对象</p><ul><li><p>·获取成员方法的作用依然是在某个对象中进行执行此方法</p></li><li><p>1.利用反射技术获取成员方法对象的方式</p><ul><li>获取类中成员方法对象</li><li>■getDeclaredMethods()</li><li>■getDeclaredMethod (String name,class&lt;?&gt;…parameterTypes)</li></ul></li><li><p>2.反射得到成员方法可以做什么？</p><ul><li><p>依然是在某个对象中触发该方法执行。</p><ul><li>object invoke(object obj,object…args)</li></ul></li><li><p>●如果某成员方法是非pubc的，需要打开权限（暴力反射），然后再触发执行</p><ul><li>setAccessible(boolean)</li></ul></li></ul></li></ul></li><li><p>反射的作用-绕过编译阶段为集合添加数据</p><ul><li><p>·反射是作用在运行时的技术，此时集合的泛型将不能产生约束了，此时是可以为集合存入其他任意类型的元素的。</p></li><li><p>·泛型只是在编译阶段可以约束集合只能操作某种数据类型，在编译成C5s文件进入运行阶段的时候，其真实类型都是ArrayList了，泛型相当于被擦除了。</p></li><li><p>1.反射为何可以给约定了泛型的集合存入其他类型的元素？</p><ul><li>●编译成Clss文件进入运行阶段的时候，泛型会自动擦除。</li><li>●反射是作用在运行时的技术，此时已经不存在泛型了。。</li></ul></li></ul></li><li><p>反射的作用-通用框架的底层原理</p><ul><li><p>反射做通用框架</p><ul><li>需求：给你任意一个对象，在不清楚对象字段的情况可以，可以把对象的字段名称和对应值存储到文件中去。</li></ul></li><li><p>1.反射的作用？</p><ul><li>·可以在运行时得到一个类的全部成分然后操作。</li><li>●可以破坏封装性。（很突出）</li><li>●也可以破坏泛型的约束性。（很突出）</li><li>●更重要的用途是适合：做Java高级框架</li></ul></li></ul></li></ul><h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li><p>◆注解概述</p><ul><li><p>。Java注解(Annotation)又称Java标注，是JDK5.0引入的一种注释机制。</p></li><li><p>。Java语言中的类、构造器、方法、成员变量、参数等都可以被注解进行标注。</p></li><li><p>注解的作用</p><ul><li>·对Java中类、方法、成员变量做标记，然后进行特殊处理，至于到底做何种处理由业务需求来决定。</li><li>·例如：JUnit框架中，标记了注解@Test的方法就可以被当成测试方法执行，而没有标记的就不能当成测试方法执行。</li></ul></li></ul></li><li><p>◆自定义注解</p><ul><li><p>自定义注解格式</p><ul><li>。自定义注解就是自己做一个注解来使用。</li></ul></li><li><p>特殊属性</p><ul><li>●value属性，如果只有一个value属性的情况下，使用value属性的时候可以省略value名称不写！</li><li>●但是如果有多个属性，且多个属性没有默认值，那么vlue名称是不能省略的。</li></ul></li></ul></li><li><p>◆元注解</p><ul><li><p>●元注解：就是注解注解的注解。</p></li><li><p>元注解有两个：</p><ul><li><p>●@Target:约束自定义注解只能在哪些地方使用，</p><ul><li>@Target中可使用的值定义在ElementType枚举类中，常用值如下</li><li>■ TYPE,类，接口</li><li>■ FIELD,成员变量</li><li>■ METHOD,成员方法</li><li>■ PARAMETER,方法参数</li><li>■ CONSTRUCTOR,构造器</li><li>■ LOCAL_VARIABLE,局部变量</li></ul></li><li><p>●@Retention:申明注解的生命周期</p><ul><li>@Retention中可使用的值定义在RetentionPolicy枚举类中，常用值如下</li><li>■ SOURCE：注解只作用在源码阶段，生成的字节码文件中不存在</li><li>■ CLASS:注解作用在源码阶段，字节码文件阶段，运行阶段不存在，默认值.</li><li>■ RUNTIME:注解作用在源码阶段，字节码文件阶段，运行阶段（开发常用）</li></ul></li></ul></li></ul></li><li><p>◆注解解析</p><ul><li><p>注解的解析</p><ul><li>●注解的操作中经常需要进行解析，注解的解析就是判断是否存在注解，存在注解就解析出内容。</li></ul></li><li><p>与注解解析相关的接口</p><ul><li>●Annotation:注解的顶级接口，注解都是Annotation类型的对象</li><li>●AnnotatedElement:该接口定义了与注解解析相关的解析方法</li><li>●所有的类成分Class,Method,Field,Constructor,都实现了AnnotatedElement:接口他们都拥有解析注解的能力：</li></ul></li><li><p>解析注解的技巧</p><ul><li>●注解在哪个成分上，我们就先拿哪个成分对象。</li><li>●比如注解作用成员方法，则要获得该成员方法对应的Method对象，再来拿上面的注解</li><li>●比如注解作用在类上，则要该类的Class对象，再来拿上面的注解</li><li>●比如注解作用在成员变量上，则要获得该成员变量对应的Fild对象，再来拿上面的注解</li></ul></li><li></li></ul></li><li><p>◆注解的应用场景一：junit框架</p></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>◆动态代理概述、快速入门</p><ul><li><p>什么是代理？</p><ul><li>·代理：指某些场景下对象会找一个代理对象，来辅助自己完成一些工作，如：歌星（经济人），买房的人（房产中介）。</li><li>代理主要是对对象的行为额外做一些辅助操作。</li></ul></li><li><p>如何创建代理对象</p><ul><li>Java中代理的代表类是：java.lang.reflect.Proxy。</li><li>Proxy提供了一个静态方法，用于为对象产生一个代理对象返回。</li></ul></li><li><p>1.代理是什么？</p><ul><li>●一个对象，用来对被代理对象的行为额外做一些辅助工作。</li></ul></li><li><p>2.在ava中实现动态代理的步骤是什么样的？</p><ul><li>●必须存在接▣</li><li>●被代理对象需要实现接▣。</li><li>●使用Proxy类提供的方法，的对象的代理对象。</li></ul></li><li><p>3.通过代理对象调用方法，执行流程是什么样的？</p><ul><li>●先走向代理</li><li>●代理可以为方法额外做一些辅助工作。</li><li>●开发真正触发对象的方法的执行。</li><li>●回到代理中，由代理负责返回结果给方法的调用者。</li></ul></li></ul></li><li><p>◆动态代理的应用案例：做性能分析、代理的好处小结</p><p>  - </p><ul><li><p>动态代理的优点</p><ul><li>可以在不改变方法源码的情况下，实现对方法功能的增强，提高了代码的复用。</li><li>简化了编程工作、提高了开发效率，同时提高了软件系统的可扩展性，。</li><li>可以为被代理对象的所有方法做代理。</li><li>非常的灵活，支持任意接口类型的实现类对象做代理，也可以直接为接本身做代理。</li></ul></li></ul></li></ul><h2 id="XML、XML解析、设计模式等"><a href="#XML、XML解析、设计模式等" class="headerlink" title="XML、XML解析、设计模式等"></a>XML、XML解析、设计模式等</h2><h3 id="XML"><a href="#XML" class="headerlink" title="XML"></a>XML</h3><ul><li><p>◆XML概述</p><ul><li><p>XML是可扩展标记语言(eXtensible Markup Language)的缩写，它是是一种数据表示格式，可以描述非常复杂的数据结构，常用于传输和存储数据。</p></li><li><p>XML的几个特点和使用场景</p><ul><li>一是纯文本，默认使用UTF-8编码；二是可嵌套；</li><li>如果把XML内容存为文件，那么它就是一个XML文件。</li><li>XML的使用场景：XML内容经常被当成消息进行网络传输，或者作为配置文件用于存储系统的信息。</li></ul></li><li><p>1.XML是什么？</p><ul><li>●XML的全称为(EXtensible Markup Language),是一种可扩展的标记语言。它是是一种数据表示格式，可以用于自定义数据格式。</li></ul></li><li><p>2.XML的作用是什么？</p><ul><li>●用于进行存储数据和传输数据</li><li>●作为软件的配置文件</li></ul></li></ul></li><li><p>◆XML的创建、语法规则</p><ul><li><p>XML的创建</p><ul><li>就是创建一个XML类型的文件，要求文件的后缀必须使用xml,如world.xml</li></ul></li><li><p>XML的语法规则</p><ul><li>●XML文件的后缀名为：xml</li><li>·文档声明必须是第一行</li></ul></li><li><p>XML的标签（元素）规则</p><ul><li>●标签由一对尖括号和合法标识符组成：<name></name>,必须存在一个根标签，有且只能有一个。</li><li>●标签必须成对出现，有开始，有结束：<name></name></li><li>●特殊的标签可以不成对，但是必须有结束标记，如：<b></b></li><b><li>●标签中可以定义属性，属性和标签名空格隔开，属性值必须用引号引起来<student id="“1”"></student></li><li>●标签需要正确的嵌套</li></b></ul><b></b></li><b><li><p>XML的其他组成</p><ul><li><p>●XML文件中可以存在CDATA区：&lt;I[CDATA[.内容.·]&gt;</p></li><li><p>●XML文件中可以存在以下特殊字符</p><ul><li>&lt;  &gt; &amp; ‘ “</li><li>&lt;   &gt;    &amp;   '   "</li></ul></li><li><p>●XML文件中可以定义注释信息：&lt;！-注释内容-&gt;</p></li></ul></li><li><p>1.XML的组成格式要求是什么样的？</p><ul><li>●文件后缀必须是xml</li><li>·文档声明必须是第一行</li><li>●必须存在一个根标签，有且只能有一个</li><li>●XML文件中可以定义注释信息：<!--注释内容--></li><li>●标签必须成对出现，有开始，有结束标签：<name></name></li><li>●必须能够正确的嵌套</li></ul></li></b></ul><b></b></li><b><li><p>◆XML文档约束方式</p><ul><li><p>问题：由于XML文件可以自定义标签，导致XML文件可以随意定义，程序在解析的时候可能出现问题。</p></li><li><p>什么是文档约束？</p><ul><li>●文档约束：是用来限定x文件中的标签以及属性应该怎么写。</li><li>以此强制约束程序员必须按照文档约束的规定来编写xml文件。</li></ul></li><li><p>文档约束的分类</p><ul><li><p>DTD</p><ul><li><p>XML的文档约束-DTD的作用和问题？</p><ul><li>·可以约束XML文件的编写。</li><li>·不能约束具体的数据类型。</li></ul></li></ul></li><li><p>schema</p><ul><li><p>文档约束-schema</p><ul><li>●schema可以约束具体的数据类型，约束能力上更强大。</li><li>●schema本身也是一个xml文件，本身也受到其他约束文件的要求，所以编写的更加严谨</li></ul></li><li><p>后缀名  .xsd</p></li></ul></li></ul></li></ul></li></b></ul><b><h3 id="XML解析技术"><a href="#XML解析技术" class="headerlink" title="XML解析技术"></a>XML解析技术</h3><ul><li><p>◆XML解析技术概述</p><ul><li><p>什么是XML解析</p><ul><li>使用程序读取XML中的数据</li></ul></li><li><p>两种解析方式</p><ul><li>●SAX解析</li><li>●DOM解析</li><li></li></ul></li><li><ul><li><p>1.Dom解析的文档对象模型是怎么样的</p><ul><li>Documenti对象：整个xml文档</li><li>Element对象：标签</li><li>Attribute对象：属性</li><li>Text对象：文本内容</li></ul></li><li><p>2.Dom解析常用技术框架</p><ul><li>·Dom4</li></ul></li></ul></li></ul></li><li><p>◆Dom4J解析XML文件</p><p>  - </p></li><li><p>◆Dom4J解析XML文件-案例实战</p></li></ul><h3 id="XML检索技术：Xpath"><a href="#XML检索技术：Xpath" class="headerlink" title="XML检索技术：Xpath"></a>XML检索技术：Xpath</h3><ul><li><p>如果需要从XML文件中检索需要的某个信息（如name)怎么解决？</p><ul><li>●Dom4j需要进行文件的全部解析，然后再寻找数据。</li><li>●Xpath技术更加适合做信息检索。</li></ul></li><li><p>XPath介绍</p><ul><li>●XPth在解析XML文档方面提供了一独树一帜的路径思想，更加优雅，高效</li><li>●XPth使用路径表达式来定位XML文档中的元素节点或属性节点。</li></ul></li><li><p>Xpath的四大检索方案</p><ul><li>●检索XML文件中的信息</li><li>●绝对路径：/根元素/子元素/孙元素</li><li>●相对路径：./子元素/孙元素</li><li>●全文检索：//contact</li><li>●属性查找：//@属性名、//元素[@属性名]、//元素[@属性名=’值]</li></ul></li></ul><h3 id="设计模式：工厂模式"><a href="#设计模式：工厂模式" class="headerlink" title="设计模式：工厂模式"></a>设计模式：工厂模式</h3><ul><li><p>什么是工厂设计模式？</p><ul><li>之前我们创建类对象时，都是使用new对象的形式创建，在很多业务场景下也提供了不直接new的方式。</li><li>工厂模式(Factory Pattern)是Java中最常用的设计模式之一，这种类型的设计模式属于创建型模式，它提供了一种获取对象的方式。</li></ul></li><li><p>工厂设计模式的作用：</p><ul><li>工厂的方法可以封装对象的创建细节，比如：为该对象进行加工和数据注入。</li><li>可以实现类与类之间的解耦操作（核心思想）。</li></ul></li></ul><h3 id="设计模式：装饰模式"><a href="#设计模式：装饰模式" class="headerlink" title="设计模式：装饰模式"></a>设计模式：装饰模式</h3><ul><li><p>什么是装饰设计模式？</p><ul><li>●创建一个新类，包装原始类，从而在新类中提升原来类的功能。</li></ul></li><li><p>装饰设计模式的作用：</p><ul><li>·作用：装饰模式指的是在不改变原类的基础上，动态地扩展一个类的功能。</li><li>·装饰模式指的是在不改变原类的基础上，动态地扩展一个类的功能</li><li>定义父类。</li><li>定义原始类，继承父类，定义功能。</li><li>定义装饰类，继承父类，包装原始类，增强功能！！</li></ul></li></ul></b></object></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 作者：赵燕军 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Web</title>
      <link href="/2023/07/16/java-web/"/>
      <url>/2023/07/16/java-web/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h1><h2 id="Java-Web-1"><a href="#Java-Web-1" class="headerlink" title="Java Web"></a>Java Web</h2><h3 id="什么是JavaWeb"><a href="#什么是JavaWeb" class="headerlink" title="什么是JavaWeb?"></a>什么是JavaWeb?</h3><ul><li>Web:全球广域网，也称为万维网(WWW),能够通过浏览器访问的网站</li><li>JavaWeb:是用Java技术来解决相关web互联网领域的技术栈</li></ul><h3 id="JavaWeb-组成"><a href="#JavaWeb-组成" class="headerlink" title="JavaWeb 组成"></a>JavaWeb 组成</h3><ul><li>1.网页：展现数据</li><li>2.数据库：存储和管理数据</li><li>3.JavaWeb程序：逻辑处理</li></ul><h3 id="Java技术栈"><a href="#Java技术栈" class="headerlink" title="Java技术栈"></a>Java技术栈</h3><ul><li><p>B/S架构</p><ul><li>B/S架构：浏览器/服务器架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可</li><li>好处：易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本</li></ul></li><li><p>C/S架构</p></li><li><p>静态资源</p><ul><li>静态资源：HTML、CSS、JavaScript、图片等。负责页面展现</li></ul></li><li><p>动态资源</p><ul><li>动态资源：Servlet、JSP等。负责逻辑处理</li></ul></li><li><p>数据库</p><ul><li>存储数据</li></ul></li><li><p>HTTP</p><ul><li>定义通信规则</li></ul></li><li><p>Web服务器</p><ul><li>Web服务器：负责解析HTTP协议，解析请求数据，并发送响应数据</li></ul></li></ul><h3 id="JavaWeb-三大组件-Servlet、Filter、Listener"><a href="#JavaWeb-三大组件-Servlet、Filter、Listener" class="headerlink" title="JavaWeb 三大组件(Servlet、Filter、Listener)"></a>JavaWeb 三大组件(Servlet、Filter、Listener)</h3><h2 id="数据库-MySQL"><a href="#数据库-MySQL" class="headerlink" title="数据库 MySQL"></a>数据库 MySQL</h2><h3 id="数据库相关概念"><a href="#数据库相关概念" class="headerlink" title="数据库相关概念"></a>数据库相关概念</h3><ul><li><p>·数据库</p><ul><li>存储数据的仓库，数据是有组织的进行存储</li><li>英文：DataBase,简称DB</li></ul></li><li><p>·数据库管理系统</p><ul><li>管理数据库的大型软件</li><li>英文：DataBase Management System,简称DBMS</li></ul></li><li><p>·SQL</p><ul><li>英文：Structured Query Language,简称SQL,结构化查询语言</li><li>操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li></ul></li><li><p>·常见的关系型数据库管理系统</p></li></ul><h3 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h3><ul><li><p>登录参数：</p><ul><li>mysql -u用户名 -p密码 -h要连接的mysql服务器的ip地址（默认127.0.0.1） -P端口号（默认3306）</li></ul></li><li><p>MySQL数据模型</p><ul><li><p>关系型数据库</p><ul><li><p>关系型数据库是建立在关系模型基础上的数据库，简单说，关系型数据库是由多张能互相连接的二维表组成的数据库</p></li><li><p>·优点</p><ul><li>1.都是使用表结构，格式一致，易于维护。</li><li>2.使用通用的SQL语言操作，使用方便，可用于复杂查询。</li><li>3.数据存储在磁盘中，安全。</li></ul></li></ul></li></ul></li></ul><h3 id="SQL"><a href="#SQL" class="headerlink" title="SQL"></a>SQL</h3><ul><li><p>·SQL简介</p><ul><li>英文：Structured Query Language,简称SQL</li><li>结构化查询语言，一门操作关系型数据库的编程语言</li><li>定义操作所有关系型数据库的统一标准</li><li>对于同一个需求，每一种数据库操作的方式可能会存在一些不一样的地方，我们称为“方言”</li></ul></li><li><p>·SQL通用语法</p><ul><li><p>1.SQL语句可以单行或多行书写，以分号结尾。</p></li><li><p>2.MySQL数据库的SQL语句不区分大小写，关键字建议使用大写。</p></li><li><p>3.注释</p><ul><li>单行注释：– 注释内容(必须加空格) 或 #注释内容(MySQL特有)</li><li>多行注释：/<em>注释</em>/</li></ul></li></ul></li><li><p>·SQL分类</p><ul><li>·DDL(Data Definition Language)数据定义语言，用来定义数据库对象：数据库，表，列等</li><li>·DML(Data Manipulation Language)数据操作语言，用来对数据库中表的数据进行增删改</li><li>·DQL(Data Query Language)数据查询语言，用来查询数据库中表的记录（数据）</li><li>·DCL(Data Control Language)数据控制语言，用来定义数据库的访问权限和安全级别，及创建用户</li></ul></li><li><p>·DDL</p><p>  - </p><pre><code>  - show database; -- 查询数据库  - create database ddl; -- 创建数据库  - create database if not exists ddl; -- 创建数据库(判断)  - drop database ddl; -- 删除数据库  - drop database if not exists ddl; -- 删除数据库(判断)  - select database(); -- 查询当前使用的数据库  - use ddl; -- 使用数据库</code></pre><ul><li><p>操作表</p><ul><li><p>·创建(Create)</p><ul><li><p>数据类型</p><ul><li><p>·MySQL支持多种类型，可以分为三类：</p><ul><li>数值</li><li>·日期</li><li>·字符串</li></ul></li><li></li></ul></li></ul></li><li><p>·查询(Retrieve)</p><ul><li><p>show tables; – 查询所有表</p></li><li><p>desc student; – 查询表结构</p><ul><li>describe student;</li></ul></li></ul></li><li><p>·修改(Update)</p><ul><li>alter table tb_student rename to tb_students; – 修改表名</li><li>alter table tb_student add money double(7,2);– 添加一列</li><li>alter table tb_student modify <code>status</code> int;– 修改数据类型</li><li>alter table tb_student change <code>status</code> state int;– 修改列名和数据类型</li><li>alter table tb_student drop <code>status</code>;– 删除列</li></ul></li><li><p>·删除(Delete)</p><ul><li>drop table tb_user; – 删除表</li><li>drop table if not exists tb_user; – 删除表(判断)</li></ul></li></ul></li></ul></li><li><p>·DML</p><ul><li><p>添加 ( insert )</p></li><li><p>删除 ( delete )</p><ul><li>如果delete语句没有加where子句，就会将所有数据全部删除</li></ul></li><li><p>修改 ( update )</p><ul><li>如果update语句没有加where子句，就会将所有数据全部修改</li></ul></li></ul></li><li><p>·DQL</p><ul><li><p>查询 ( select )</p><ul><li><p>·基础查询</p><ul><li><p>查询多个字段</p><ul><li>select * from student;</li><li>select Sno,Sname from student;</li></ul></li><li><p>取别名 as (可以省略)</p></li><li><p>去除重复的记录 distinct</p></li></ul></li><li><p>·条件查询(where)</p><ul><li><p>1.条件查询语法</p><ul><li>SELECT字段列表FROM表名WHERE条件列表；</li></ul></li><li><p>2.条件</p><p>  - </p><ul><li>and &amp;&amp; 表示与；or || 表示或  not ! 表示非</li><li>between and 用来查询-到-之间的数据</li><li>in 用来查询- -的数据</li><li>null 只能使用 is 或 is not 进行比较</li><li>通配符(用line进行模糊查询) _ 表示单个字符； % 表示多个字符</li></ul></li></ul></li><li><p>·分组查询(group by)</p><ul><li><p>聚合函数</p><ul><li><p>1.概念：</p><ul><li>将一列数据作为一个整体，进行纵向计算。</li></ul></li><li><p>2.聚合函数分类：</p><ul><li>count()</li><li>max()</li><li>min()</li><li>sum()</li><li>avg()</li></ul></li><li><p>3.聚合函数语法：</p><ul><li>SELECT 聚合函数名（列名）FROM 表；</li><li>注意：null值不参与所有聚合函数运算</li></ul></li></ul></li><li><p>分组查询</p><ul><li><p>1.分组查询语法</p><ul><li>注意：分组之后，查询的字段为聚合函数和分组字段，查询其他字段无任何意义</li></ul></li><li><p>where和having区别：</p><ul><li>·执行时机不一样：where是分组之前进行限定，不满足where条件，则不参与分组，而having是分组之后对结果进行过滤，</li><li>·可判断的条件不一样：where不能对聚合函数进行判断，having可以。</li><li>执行顺序：where&gt;聚合函数&gt;having</li></ul></li></ul></li></ul></li><li><p>·排序查询(order by)</p><ul><li><p>1.排序查询语法；</p><ul><li><p>排序方式：</p><ul><li>ASC:升序排列（默认值）</li><li>DESC:降序排列</li></ul></li><li><p>注意：如果有多个排序条件，当前边的条件值一样时，才会根据第二条件进行排序</p></li></ul></li></ul></li><li><p>·分页查询(limit)</p><ul><li><p>1.分页查询语法</p><ul><li>起始索引：从0开始</li><li>计算公式：起始索引 =（当前页码1）·每页显示的条数</li></ul></li><li><p>tips:</p><ul><li>分页查询limit是MySQL数据库的方言</li><li>Oracle分页查询使用rownumber</li><li>SQL Server分页查询使用top</li></ul></li></ul></li></ul></li></ul></li><li><p>DCL</p><ul><li><p>约束</p><ul><li><p>概念&amp;分类</p><ul><li><p>1.约束的概念</p><ul><li>·约束是作用于表中列上的规侧，用于限制加入表的数据</li><li>·约束的存在保证了数据库中数据的正确性、有效性和完整性</li></ul></li><li><p>2.约束的分类</p><ul><li>Tips:MySQL不支持检查约束</li></ul></li><li><p>主键约束 primary key</p></li><li><p>非空约束 not null</p><ul><li><p>1.概念</p><ul><li>·非空约束用于保证列中所有数据不能有null值</li></ul></li><li><p>2.语法</p><ul><li><p>(1)添加约束</p><ul><li>创建表时添加非空约束</li><li>建完表后添加非空约束</li></ul></li><li><p>(2)删除约束</p></li></ul></li></ul></li><li><p>唯一约束 unique</p></li><li><p>外键约束 foreign key</p><ul><li><p>1.概念</p><ul><li>·外键用来让两个表的数据之间建立链接，保证数据的一致性和完整性</li></ul></li></ul></li><li><p>默认约束 default</p></li></ul></li></ul></li><li><p>数据库设计</p><ul><li><p>·数据库设计简介</p><ul><li><p>1.软件的研发步骤</p><p>  - </p></li><li><p>2.数据库设计慨念</p><ul><li>数据库设计就是根据业务系统的具体需求，结合我们所选用的DBMS,为这个业务系统构造出最优的数据存储模型</li><li>建立数据库中的表结构以及表与表之间的关联关系的过程。</li><li>有哪些表？表里有哪些字段？表和表之间有什么关系？</li></ul></li><li><p>3.数据库设计的步骤</p><ul><li>①需求分析（数据是什么？数据具有哪些属性？数据与属性的特点是什么）</li><li>②逻辑分析（通过E-R图对数据库进行逻辑建模，不需要考虑我们所选用的数据库管理系统）</li><li>③物理设计（根据数据库自身的特点把逻辑设计转换为物理设计）</li><li>④维护设计(1对新的需求进行建表2.表优化)</li></ul></li><li><p>1.数据库设计设计什么？</p><ul><li>·表和表之间是什么关系</li><li>表里有哪些字段</li><li>有哪些表</li></ul></li><li><p>2.表关系有哪几种？</p><ul><li>一对一</li><li>一对多</li><li>·多对多</li></ul></li></ul></li><li><p>表关系</p><ul><li><p>·一对一</p><ul><li>一对一关系多用于表拆分，将一个实体中经常使用的字段放一张表，不经常使用的字段放另一张表，用于提升查询性能</li><li>实现方式：在任意一方加入外键，关联另一方主键，并且设置外键为唯一(UNIQUE)</li></ul></li><li><p>·一对多：</p><ul><li>实现方式：在多的一方建立外键，指向一的一方的主键</li></ul></li><li><p>·多对多：</p><ul><li>实现方式：建立第三张中间表，中间表至少包含两个外键，分别关联两方主键</li></ul></li></ul></li><li><p>·数据库设计案例</p><p>  - </p><pre><code>  - ·数据库设计案例.docx</code></pre></li></ul></li><li><p>多表查询</p><ul><li><p>多表查询简介</p><ul><li><p>笛卡尔积：取A,B集合所有组合情况</p></li><li><p>多表查询：从多张表查询数据</p><ul><li><p>连接查询</p><ul><li><blockquote><p>内连接：相当于查询AB交集数据</p></blockquote></li><li><blockquote><p>外连接：</p></blockquote><ul><li>左外连接：相当于查询A表所有数据和交集部分数据</li><li>右外连接：相当于查询B表所有数据和交集部分数据</li></ul></li></ul></li><li><p>子查询</p></li></ul></li></ul></li><li><p>内连接</p><ul><li>内连接相当于查询AB交集数据</li></ul></li><li><p>外连接</p><ul><li>左外连接：相当于查询A表所有数据和交集部分数据</li><li>右外连接：相当于查询B表所有数据和交集部分数据</li></ul></li><li><p>子查询</p><ul><li><p>1.子查询概念：</p><ul><li><blockquote><p>查询中嵌套查询，称嵌套查询为子查询</p></blockquote></li></ul></li><li><p>2.子查询根据查询结果不同，作用不同：</p><ul><li>单行单列：作为条件值，使用=  != &gt; &lt;等进行条件判断</li><li>多行单列：作为条件值，使用in等关键字进行条件判断</li><li>多行多列：作为虚拟表</li></ul></li></ul></li><li><p>多表查询案例</p></li></ul></li><li><p>事务</p><ul><li><p>事务简介</p><ul><li>数据库的事务 是一种机制、一个操作序列，包含了一组数据库操作命令</li><li>事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么同时成功，要么同时失败</li><li>事务是一个不可分割的工作逻辑单元</li></ul></li><li><p>事务四大特征 ( ACID )</p><ul><li>原子性(Atomicity):事务是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>·一致性(Consistency)事务完成时，必须使所有的数据都保持一致状态</li><li>·隔离性(Isolation):多个事务之间，操作的可见性</li><li>·持久性(Durability):事务一旦提交或回滚，它对数据库中的数据的改变就是永久的</li></ul></li></ul></li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="JDBC-Maven-MyBatis"><a href="#JDBC-Maven-MyBatis" class="headerlink" title="JDBC  Maven   MyBatis"></a>JDBC  Maven   MyBatis</h2><h3 id="数据库连接技术-JDBC"><a href="#数据库连接技术-JDBC" class="headerlink" title="数据库连接技术 JDBC"></a>数据库连接技术 JDBC</h3><ul><li><p>JDBC简介</p><ul><li><p>JDBC概念</p><ul><li>·JDBC就是使用Java语言操作关系型数据库的一套API</li><li>·全称：(Java DataBase Connectivity)Java数据库连接</li></ul></li><li><p>JDBC本质：</p><ul><li>·官方(sum公司)定义的一套操作所有关系型数据库的规则，即接口</li><li>·各个数据库厂商去实现这套接口，提供数据库驱动jar包</li><li>我们可以使用这套接口(UDBC)编程，真正执行的代码是驱动jar包中的实现类</li></ul></li><li><p>JDBC好处：</p><ul><li>·各数据库厂商使用相同的接口，Java代码不需要针对不同数据库分别开发</li><li>·可随时替换底层数据库，访问数据库的Java代码基本不变</li></ul></li></ul></li><li><p>JDBC快速入门</p><ul><li><p>步骤</p><ul><li>0.创健工程，导入驱动jar包</li><li>1.注册驱动</li><li>2.获取连接</li><li>3.定义SQL语句</li><li>4.获取执行SQL对像</li><li>5.执行SQL</li><li>6.处理返回结果</li><li>7.释放资源</li></ul></li></ul></li><li><p>JDBC API详解</p><ul><li><p>DriverManager</p><ul><li><p>DriverManager(驱动管理类)作用：</p><ul><li>1.注册驱动</li><li>2.获取数据库连接</li></ul></li><li><p>1.注册驱动</p><ul><li><p>提示：</p><ul><li>MySQL5之后的驱动泡，可以省路注册驱动的步骤</li><li>自动加载jar包中META-lNF/services/java.sql.Driver文件中的驱动类</li></ul></li></ul></li><li><p>2.获取连接</p><ul><li><p>参数</p><ul><li><p>1.url:连接路径</p><ul><li><p>语法：jdbc:mysql://ip地址（域名）:端口号/数据库名称 ？参数键值对1 &amp; 参数键值对2.…</p></li><li><p>示例：</p><ul><li>jdbc:mysql://127.0.0.1:3306/ddl</li><li>jdbc:mysql://localhost:3306/ddl</li></ul></li><li><p>细节：</p><ul><li>如果连接的是本机mysql服务器，并且mysql服务默认端口是3306，则url可以简写为：jdbc:mysql:///数据库名称？参数键值对</li><li>配置useSSL=false参数，禁用安全连接方式，解决警告提示</li></ul></li></ul></li><li><p>2.user:用户名</p></li><li><p>3.password:密码</p></li></ul></li></ul></li></ul></li><li><p>Connection</p><ul><li><p>·Connection(数据库连接对象)作用：</p><ul><li>1.获取执行SQL的对象</li><li>2.管理事务</li></ul></li><li><p>1.获取执行SQL的对象</p><ul><li><p>普通执行SQL对象</p><ul><li>Statement createStatement()</li></ul></li><li><p>预编译SQL的执行SQL对象：防止SQL注入</p><ul><li>PreparedStatement prepareStatement(sql)</li></ul></li><li><p>执行存储过程的对象</p><ul><li>CallableStatement prepareCall(sql)</li></ul></li></ul></li><li><p>2.事务管理</p><ul><li><p>MySQL事务管理</p><ul><li>开启事务：BEGIN:START TRANSACTION:</li><li>提交事务：COMMIT</li><li>回滚事务：ROLLBACK</li><li>MySQL默认自动提交事务</li></ul></li><li><p>JDBC事务管理：Connection接口中定义了3个对应的方法</p><ul><li>开启事务：setAutoCommit(boolean autoCommit):true为自动提交事务；false为手动提交事务，即为开启事务</li><li>提交事务：commit()</li><li>回滚事务：rollback()</li></ul></li></ul></li></ul></li><li><p>Statement</p><ul><li><p>Statement作用：</p><ul><li><p>1.执行SQL语句</p><ul><li><p>int executeUpdate(sql): 执行DML、DDL语句</p><ul><li><p>返回值：</p><ul><li>(1)DML语句影响的行数</li><li>(2)DDL语句执行后，执行成功也可能返回0</li></ul></li></ul></li><li><p>ResultSet executeQuery(sql): 执行DQL语句</p><ul><li>返回值：ResultSet结果集对象</li></ul></li></ul></li></ul></li></ul></li><li><p>ResultSet</p><ul><li><p>ResultSet(结果集对像)作用：</p><ul><li><p>1.封装了DQL查询语句的结果</p><ul><li><p>获取查询结果</p><ul><li><p>boolean next(): </p><ul><li><p>(1)将光标从当前位置向前移动一行</p></li><li><p>(2)判断当前行是否为有效行</p></li><li><p>返回值：</p><ul><li>true:有效行，当前行有数据</li><li>false:无效行，当前行没有数据</li></ul></li></ul></li></ul></li><li><p>XXX getXxx(参数)：获取数据</p><ul><li><p>xxx:数据类型；如：int getInt(参数)：String getString(参数)</p></li><li><p>参数：</p><ul><li>int:列的编号，从1开始</li><li>String:列的名称</li></ul></li></ul></li></ul></li></ul></li><li><p>·使用步骤：</p><ul><li><p>1.游标向下移动一行，并判断该行否有数据：next()</p></li><li><p>2.获取数据：getXxx(参数)</p><ul><li>/循环判断游标是否是最后一行末尾</li><li>while(rs.next(){</li><li>/获取数据</li><li>rs.getXxx(参数)：</li></ul></li></ul></li></ul></li><li><p>PreparedStatement</p><ul><li><p>PreparedStatement作用：</p><ul><li><p>1.预编译SQL语句并执行：预防SQL注入问题</p><ul><li>①获取PreparedStatement对象</li><li>②设置参数值</li><li>③执行SQL</li></ul></li><li><p>·SQL注入</p><ul><li>·SQL注入是通过操作输入来修改事先定义好的SQL语句，用以达到执行代码对服务器进行攻击的方法。</li></ul></li></ul></li><li><p>PreparedStatement好处：</p><ul><li><p>1.预编译SQL,性能更高</p></li><li><p>2.防止SQL注入：将敏感字符进行转义</p><ul><li>①PreparedStatement预编译功能开启：useServerPrepStmts=true</li><li>②配置MySQL执行日志（重启mysql服务后生效）</li></ul></li></ul></li><li><p>PreparedStatement原理</p><ul><li>1.在获取PreparedStatement对象时，将sql语句发送给mysql服务器进行检查，编译（这些步骤很耗时）</li><li>2.执行时就不用再进行这些步骤了，速度更快</li><li>3.如果sql模板一样，则只需要进行一次检查、编译</li></ul></li></ul></li></ul></li><li><p>数据库连接池</p><ul><li><p>数据库连接池简介</p><ul><li><p>数据库连接池是个容器，负责分配、管理数据库连接(Connection)</p></li><li><p>它允许应用程序重复使用一个现有的数据库连接，而不是再重新建立一个：</p></li><li><p>释放空闲时间超过最大空闲时间的数据库连接来避免因为没有释放数据库连接而引起的数据库连接遗漏</p></li><li><p>好处：</p><ul><li>·资源重用</li><li>提升系统响应速度</li><li>避免数据库连接遗漏</li></ul></li></ul></li><li><p>数据库连接池实现</p><ul><li><p>·标准接口：DataSource</p><ul><li><p>官方(SUM)提供的数据库连接池标准接口，由第三方组织实现此接口。</p></li><li><p>功能：获取连接</p><ul><li>Connection getConnection()</li></ul></li></ul></li><li><p>·常见的数据库连接池：</p><ul><li>·DBCP</li><li>C3PO</li><li>·Druid</li></ul></li><li><p>·Druid(德鲁伊)</p><ul><li>·Druid连接池是阿里巴巴开源的数据库连接池项目</li><li>·功能强大，性能优秀，是Java语言最好的数据库连接池之一</li></ul></li></ul></li><li><p>Druid数据库连接池</p></li></ul></li></ul><h3 id="自动化构建工具-Maven"><a href="#自动化构建工具-Maven" class="headerlink" title="自动化构建工具 Maven"></a>自动化构建工具 Maven</h3><ul><li><p>Maven</p><ul><li><p>主要功能</p><ul><li><p>Maven是专门用于管理和构建ava项目的工具，它的主要功能有：</p><ul><li><blockquote><p>提供了一套标准化的项目结构</p></blockquote></li><li><blockquote><p>提供了一套标准化的构建流程（编译，测试，打包，发布…）</p></blockquote></li><li><blockquote><p>提供了一套依赖管理机制</p></blockquote></li></ul></li><li><p>Maven提供了一套标准化的项目结构，所有IDE使用Maven构建的项目结构完全一样，所有IDE创建的Maven项目可以通用</p></li><li></li></ul></li><li><p>标准化的构建流程</p><p>  - </p><ul><li>Maven提供了一套简单的命令来完成项目构建</li></ul></li><li><p>依赖管理</p><ul><li>依赖管理其实就是管理你项目所依赖的第三方资源(jar包、插件.…)</li></ul></li></ul></li><li><p>Maven简介</p><ul><li><p>·Apache Maven.是一个项目管理和构建工具，它基于项目对象模型(POM)的概念，通过一小段描述信息来管理项目的构建、报告和文档</p></li><li><p>·官网：</p><ul><li><a href="https://maven.apache.org/">https://maven.apache.org/</a></li></ul></li><li><p>Maven作用：</p><ul><li>标准化的项目结构</li><li>标准化的构建流程</li><li>方便的依赖管理</li></ul></li><li><p>Moven 模型</p><ul><li>项目对象模型(Project Object Model)</li><li>依赖管理模型(Dependency)</li><li>插件(Plugin)</li></ul></li><li><p>Moven 仓库</p><ul><li><p>本地仓库：自己计算机上的一个目录</p></li><li><p>中央仓库：由Maven团队维护的全球唯一的仓库</p><ul><li>地址：<a href="https://repo1.maven.org/maven2/">https://repo1.maven.org/maven2/</a></li></ul></li><li><p>远程仓库(私服)：一般由公司团队搭建的私有仓库</p></li><li><p>当项目中使用坐标引入对应依赖衡jar包后，首先会查找本地仓库中是否有对应的jar包：</p><ul><li>如果有，则在项目直接引用：</li><li>如果没有，则去中央仓库中下载对应的jar包到本地仓库。</li></ul></li><li><p>还可以搭建远程仓库，将来jar包的查找顺序则变为：</p><ul><li>本地仓库→远程仓库→中央仓库</li></ul></li></ul></li></ul></li><li><p>Maven安装配置</p></li><li><p>Maven基本使用</p><ul><li><p>Maven常用命令</p><ul><li>compile:编译</li><li>clean:清理</li><li>test:测试</li><li>package:打包</li><li>install:安装</li></ul></li><li><p>Maven生命周期</p><ul><li><p>·Maven构建项目生命周期描述的是一次构建过程经历经历了多少个事件</p></li><li><p>Maven对项目构建的生命周期划分为3套</p><ul><li>clean:清理工作</li><li>default:核心工作，例如编译，测试，打包，安装等</li><li>site:产生报告，发布站点等</li></ul></li><li><p>同一生命周期内，执行后边的命令，前边的所有命令会自动执行</p></li></ul></li></ul></li><li><p><strong>IDEA配置Maven</strong></p><ul><li><p>IDEA配置Maven环境</p></li><li><p>Maven坐标详解</p><ul><li><p>什么是坐标？</p><ul><li>Maven中的坐标是资源的唯一标识</li><li>使用坐标来定义项目或引入项目中需要的依赖</li></ul></li><li><p>Maven坐标主要组成</p><ul><li>groupld:定义当前Maven项目隶属组织名称（通常是域名反写，例如：com.itheima</li><li>artifactld:定义当前Maven项目名称（通常是模块名称，例如order-service、goods-service)</li><li>version:定义当前项目版本号</li></ul></li></ul></li><li><p>IDEA创建Maven项目</p></li><li><p>IDEA导入Maven项目</p></li></ul></li><li><p>依赖管理</p><ul><li><p>使用坐标导入jar包</p><ul><li>1.在pom.xml中编写<dependencies>标签</dependencies></li><li>2.在<a href="dependencies:">dependencies:</a>标签中使用<dependency>:引l入坐标</dependency></li><li>3.定义坐标的groupld,artifactld,version</li><li>4.点击刷新按钮，使坐标生效</li></ul></li><li><p>依赖范围</p><ul><li>通过设置坐标的依赖范围(scope),可以设置对应jar包的作用范围：编译环境、测试环境、运行环境</li><li></li></ul></li></ul></li></ul><h3 id="数据持久层框架-MyBatis"><a href="#数据持久层框架-MyBatis" class="headerlink" title="数据持久层框架 MyBatis"></a>数据持久层框架 MyBatis</h3><ul><li><p>MyBatis</p><ul><li><p>什么是MyBatis</p><ul><li>MyBatis是一款优秀的持久层框架，用于简化JDBC开发</li><li>MyBatis是Apache的一个开源项目iBatis,2010年这个项由apache software foundation迁移到了google code,.并且改名为MyBatis。2013年11月迁移到Github</li><li>官网：<a href="https://mybatis.org/mybatis-3/zh/index.html">https://mybatis.org/mybatis-3/zh/index.html</a></li></ul></li><li><p>持久层</p><ul><li>·负责将数据到保存到数据库的那一层代码</li><li>JavaEE三层架构：表现层、业务层、持久层</li></ul></li><li><p>框架</p><ul><li>框架就是一个半成品软件，是一套可重用的、通用的、软件基础代码模型</li><li>在框架的基础之上构建软件编写更加高效、规范、通用、可扩展</li></ul></li><li><p>MyBatis免除了几乎所有的JDBC代码以及设置参数和获取结果集的工作</p></li></ul></li><li><p>MyBatis快速入门</p><ul><li><p>解决SQL映射文件的警告提示</p><ul><li>产生原因：Idea和数据库没有建立连接，不识别表信息</li><li>解决方式：在ldea中配置MySQL数据库连接</li></ul></li><li><p>查询user表中所有数据</p><ul><li><p>1.创建user表，添加数据</p></li><li><p>2.创建模块，导入坐标</p></li><li><p>3.编写MyBatis核心配置文件-&gt;替换连接信息解决硬编码问题</p></li><li><p>4.编写SQL映射文件-&gt;统一管理sq语句，解决硬编码问题</p></li><li><p>5.编码</p><ul><li>1.定义P0J0类</li><li>2.加载核心配置文件，获取SqlSessionFactory对象</li><li>3.获取SqlSession对象，执行SQL语句</li><li>4.释放资源</li></ul></li></ul></li></ul></li><li><p>MyBatis核心配置文件</p></li><li><p>Mapper代理开发</p><ul><li><p>目的</p><ul><li>解决原生方式中的硬编码</li><li>简化后期执行SQL</li></ul></li><li><p>使用Mapper代理方式</p><ul><li><p>1.定义与SQL映射文件同名的Mapper接口，并且将Mapper接口和SQL映射文件放置在同一目录下</p></li><li><p>2.设置SQL映射文件的namespace.属性为Mapperf接口全限定名</p></li><li><p>3.在Mapper接口中定义方法，方法名就是SQL映射文件中sql语句的id,并保持参数类型和返回值类型一致</p></li><li><p>4.编码</p><ul><li>1.通过SqlSession的getMapper方法获取Mapper接口的代理对象</li><li>2.调用对应方法完成sq的执行</li></ul></li><li><p>细节：如果Mapper接口名称和SQL映射文件名称相同，并在同一目录下，则可以使用包扫描的方式简化SQL映射文件的加载</p></li></ul></li></ul></li><li><p>MyBatis核心配置文件详解</p><ul><li><p>MyBatis 的配置文件包含了会深深影响 MyBatis 行为的设置和属性信息。 配置文档的顶层结构如下：</p></li><li><p>configuration（配置）</p><ul><li><p>properties（属性）</p></li><li><p>settings（设置）</p></li><li><p>typeAliases（类型别名）</p></li><li><p>typeHandlers（类型处理器）</p></li><li><p>objectFactory（对象工厂）</p></li><li><p>plugins（插件）</p></li><li><p>environments（环境配置）</p><ul><li><p>environment（环境变量）</p><ul><li>transactionManager（事务管理器）</li><li>dataSource（数据源）</li></ul></li></ul></li><li><p>databaseIdProvider（数据库厂商标识）</p></li><li><p>mappers（映射器）</p></li></ul></li></ul></li><li><p>配置文件完成增删改查</p><ul><li><p>MyBatis完成操作需要几步？</p><ul><li>三步：编写接口方法-&gt;编写$QL-&gt;执行方法</li></ul></li><li><p>数据库表的字段名称  和  实体类的属性名称 不一样，则不能自动封装数据</p><ul><li><ul><li>起别名：对不一样的列名起别名，让别名和实体类的属性名一样</li></ul><ul><li><ul><li>缺点：每次查询都要定义一次别名</li></ul></li></ul></li><li><ul><li>sql片段</li></ul><ul><li><ul><li>缺点：不灵活</li></ul></li></ul></li><li><ul><li>resultMap：</li></ul><ul><li><ol><li>定义<resultmap>标签</resultmap></li></ol><ul><li>id：唯一标识</li><li>type：映射的类型，支持别名</li></ul></li><li><ol start="2"><li>在<select>标签中，使用resultMap属性替换 resultType属性id：完成主键字段的映射column：表的列名property：实体类的属性名result：完成一般字段的映射column：表的列名property：实体类的属性名参数占位符#{}:会将其替换为 ?，为了防止SQL注入${}：拼sql。会存在SQL注入问题使用时机：参数传递的时候：#{}表名或者列名不固定的情况下：${} 会存在SQL注入问题参数类型：parameterType：可以省略特殊字符处理：转义字符：CDATA区:MyBatis参数传递MyBatis接口方法中可以接收各种各样的参数，MyBatis底层对于这些参数进行不同的封装处理方式单个参数：1.P00类型：POJO类型：直接使用，属性名 和 参数占位符名称 一致2.Map集合：Map集合：直接使用，键名 和 参数占位符名称 一致3.Collection:Collection：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名map.put(“arg()”,collection集合);map.put(“collection”,collection集合);4.List:List：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名map.put(“arg0”,list集合);map.put(“collection”,list集合);map.put(“list”,list集合);5.Array:Array：封装为Map集合，可以使用@Param注解，替换Map集合中默认的arg键名map.put(“arg()”,数组);map.put(“array”,数组);6.其他类型：其他类型：直接使用多个参数：多个参数：封装为Map集合,可以使用@Param注解，替换Map集合中默认的arg键名        map.put("arg0",参数值1)        map.put("param1",参数值1)        map.put("param2",参数值2)        map.put("agr1",参数值2)        ---------------@Param("username")        map.put("username",参数值1)        map.put("param1",参数值1)        map.put("param2",参数值2)        map.put("agr1",参数值2)MyBatis提供了ParamNameResolver类来进行参数封装建议：将来都使用@Param注解来修改Map集合中默认的键名，并使用修改后的名称来获取值，这样可读性更高！注解完成增删改查使用注解开发会比配置文件开发更加方便查询：@Select添加：@Insert修改：@Update删除：@Delete提示：注解完成简单功能配置文件完成复杂功能动态SQL要完成的功能列表清单：1.查询查询所有数据查看详情条件查询参数接收散装参数：如果方法中有多个参数，需要使用@Param(“SQL参数占位符名称”)对象参数:对象的属性名称要和参数占位符名称一致map集合参数SQL语句设置多个参数有几种方式？1)散装参数：需要使用@Param(“SQL中的参数占位符名称)2)实体类封装参数*只需要保证SQL中的参数名和实体类属性名对应上，即可设置成功3)map集合*只需要保证SQL中的参数名和map集合的键的名称对应上，即可设置成功查询-多条件-动态条件查询动态条件查询if: 条件判断test：逻辑表达式问题：恒等式 替换 where 关键字动态SQLif:用于判断参数是否有值，使用test属性进行条件判断*存在的问题：第一个条件不需要逻辑运算符*解决方案：1)使用恒等式让所有条件格式都一样2)标签替换where关键字查询-单条件-动态条件查询从多个条件中选择一个choose(when,otherwise):选提，类似于Java中的switch语句2.添加主键返回    delete from tb_brand where id = #{id};    3.修改修改全部字段修改动态字段4.删除删除一个批量删除mybatis会将数组参数，封装为一个Map集合。默认：array = 数组使用@Param注解改变map集合的默认key的名称HTML   CSS  JS网页开发技术 HTML超文本标记语言  HTML  HTML是一门语言，所有的网页都是用HTML这门语言编写出来的超文本：超越了文本的限制，比普通文本更强大。除了文字信息，还可以定义图片、音频、视频等内容标记语言：由标签构成的语言HTML运行在浏览器上，HTML标签由浏览器来解析HTML标签都是预定义好的。例如：使用展示图片W3C标准：网页主要由三部分组成结构：HTML表现：CSS行为：JavaScriptHTML快速入门1.HTML文件以.htm或.html为扩展名2.HTML结构标签      定义HTML文档     定义关于文档的信息      定义文档的标题    定义文档的主体3.HTML标签不区分大小写4.HTML标签属性值单双引皆可5.HTML语法松散基础标签标题标签是通过  -  等标签进行定义的生成h1~h6快捷键：     h$*6属性alignleft左对齐（默认）center居中right右对齐段落标签是通过  标签进行定义的链接标签是通过  标签进行定义的属性href指定链接的地址图像标签是通过  标签进行定义的属性src指定图片的地址width图片的宽度height图片的高度fontface字体属性size字号属性color颜色属性子主题 6子主题 7子主题 8子主题 9子主题 10子主题 11图片、音频、视频标签超链接标签列表标签表格标签布局标签表单标签HTML元素指的是从开始标签（start tag）到结束标签（end tag）的所有代码开始标签常被称为开放标签（opening tag），结束标签常称为闭合标签（closing tag）HTML 属性HTML 标签可以拥有属性。属性提供了有关 HTML 元素的更多的信息。属性总是以名称/值对的形式出现，比如：name=”value”。属性总是在 HTML 元素的开始标签中规定在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号样式表技术 CSS网页脚本技术 JavaScriptJSHTTP   Tomcat    ServletJavaWeb技术栈B/S架构：Browser/Server,浏览器/服务器架构模式，它的特点是，客户端只需要浏览器，应用程序的逻辑和数据都存储在服务器端。浏览器只需要请求服务器，获取Web资源，服务器把Web资源发送给浏览器即可好处：易于维护升级：服务器端升级后，客户端无需任何部署就可以使用到新的版本静态资源：HTML、CSS、JavaScript、图片等。负责页面展现动态资源：Servlet、JSP等。负责逻辑处理数据库：负责存储数据Wb服务器：负责解析HTTP协议，解析请求数据，并发送响应数据超文本传输协议  HTTP概念：超文本传输协议，规定了浏览器和服务器之间数据传输的规则HTTP协议特点：1.基于TCP协议：面向连接，安全2.基于请求-响应模型的：一次请求对应一次响应3.HTTP协议是无状态的协议：对于事务处理没有记忆能力。每次请求-响应都是独立的缺点：多次请求间不能共享数据。优点：速度快HTTP请求数据格式请求数据分为3部分：1.请求行：请求数据的第一行。其中GET表示请求方式，表示请求资源路径，HTTP/1.1表示协议版本2.请求头：第二行开始，格式为key:value形式常见的HTTP请求头：Host:表示请求的主机名User-Agent:浏览器版本，例如Chrome浏览器的标识类似Mozilla/5.0Chrome/79,IE浏览器的标识类似Mozilla/5.0( Vindows NT.)like Gecko:Accept:表示浏览器能接收的资源类型，如text/,image/产或者/*表示所有；Accept-Language:表示浏览器偏好的语言，服务器可以据此返回不同语言的网页；Accept-Encoding:表示浏览器可以支持的压缩类型，例如gzip,deflate等.3.请求体：POST请求的最后一部分，存放请求参数GET请求和POST请求区别：1.GET请求请求参数在请求行中，没有请求体。POST请求请求参数在请求体中2.GET请求请求参数大小有限制，POST没有HTTP响应数据格式响应数据分为3部分：1.响应行：响应数据的第一行。其中HTTP/1.1表示协议版本，200表示响应状态码，OK表示状态码描述2.响应头：第二行开始，格式为key:valuej形式常见的HTTP响应头：Content-Type:表示该响应内容的类型，例如text/html,image/jpeg:Content–Length:表示该响应内容的长度（字节数）：Content-Encoding:表示该响应压缩算法，例如gzip;Cache-Control:指示客户端应如何缓存，例如max-age=300表示可以最多缓存300秒3.响应体：最后一部分。存放响应数据状态码状态码分类说明1xx响应中一一临时状态码，表示请求已经接受，告诉客户端应该继续请求或老如果它已经完戒则忽略它2xx成功一一表示请求已经被成功接收，处理已完成3xx重定向一一重定向到其它地方：它让客户端再发起一个请求以完成整个处理.4xx客户端错误一一处理发生错误。责任在客户端。如：客户端的请求一个不存在的资源，客户端未被授权，禁止访问等5xx服务器端错误*一一处理发生错误，责任在服务端。如：服务端抛出异常，路由出错。HTTP版本不支持等https://cloud.tencent.com/developer/chapter/13553HTTP协议的默认端口号：80Web服务器   TomcatWeb服务器是一个应该程序（软件），对HTTP协议的操作进行封装，使得程序员不必直接对协议进行操作，让web开发更加便捷。主要功能是“提供网上信息浏览服务”简介概念：Tomcat是Apache软件基金会一个核心项目，是一个开源免费的轻量级Web服务器，支持Servlet/JSP少量JavaEE规范。JavaEE:Java Enterprise Edition,Java企业版。指ava企业级开发的技术规范总和。包含l3项技术规范：JDBC、JNDI、EJB、RMl、JSP、Servlet、XML、JMS、Java IDL、JTS、JTA、JavaMail、JAFTomcat也被称为Web容器、Servlet容器。Servlet需要依赖于Tomcat才能运行Web服务器作用？封装HTTP协议操作，简化开发可以将wb项目部署到服务器中，对外提供网上浏览服务Tomcat是一个轻量级的Web服务器，支持Servlet/JSP少量JavaEE规范，也称为Web容器，Servlet容器基本使用：安装、卸载、启动、关闭、配置、部署项目HTTP协议默认端口号为80，如果将Tomcati端口号改为80，则将来访问Tomcat时，将不用输入端口号Tomcat-部署项目·将项目放置到webapps目录下，即部署完成·一般JavaWebl项目会被打成war包，然后将war包放到webapps目录下，Tomcat会自动解压缩war文件IDEA中创建Maven Web项目编译后的ava字节码文件和resources的资源文件，放到WEB-lNF下的classes目录下pom.xml中依赖坐标对应的jar包，放入WEB-NF下的Iib目录下IDEA中使用Tomcat动态Web资源开发技术   Servle快速入门Servlet是Java提供的一门动态web资源开发技术Servlet是avaEE规范之一，其实就是一个接口，将来我们需要定义Servlet类实现Servlet接口，并由web服务器运行Servlet1.创建web项目，导入Servlet依赖坐标2.创建：定义一个类，实现Servlet接口，并重写接口中所有方法，并在service方法中输入一句话3.配置：在类上使用@VebServlet注解，配置该Servlet的访问路径4.访问：启动Tomcat,浏览器输入URL访问该ServletServlet执行流程1.Servlet由谁创建？Servlet方法由谁调用？Servlet由web服务器创建，Servlet方法由web服务器调用。2.服务器怎么知道Servlet中一定有service方法？,因为我们自定义的Servlet,必须实现Servlet接口并复写其方法，而Servlet接口中有service方法Servlet生命周期Servlet生命周期·对象的生命周期指一个对象从被创建到被销毁的整个过程·Servleti运行在Servlet容器(web服务器)中，其生命周期由容器来管理，分为4个阶段：1.加载和实例化：默认情况下，当Servlet第一次被访问时，由容器创建Servlet对象2.初始化：在Servlet?实例化之后，容器将调用Servlet的init(0方法初始化这个对象，完成一些如加载配置文件、创建连接等初始化的工作。该方法只调用一次3.请求处理：每次请求Servlet时，Servlet容器都会调用Servlet的service()方法对请求进行处理。4.服务终止：当需要释放内存或者容器关闭时，容器就会调用Servlet实例的destroy()方法完成资源的释放，在destroy(）方法调用之后，容器会释放这个Servlet()实例，该实例随后会被Java的垃圾收集器所回收Servlet方法介绍void init(ServletConfig config)初始化方法，在Servleti被创建时执行，只执行一次void service(ServletRequest req,ServletResponse res)提供服务方法，每次Servlet被访问，都会调用该方法void destroy()销毁方法，当Servleti被销毁时，调用该方法。在内存释放或服务器关闭时销毁ServletServletConfig getServletConfig()获取ServletConfig对象String getServletInfo()获取Servlet信息Servlet体系结构我们将来开发B/S架构的wb项目，都是针对HTTP协议,所以我们自定义Servlet,会继承HttpServlet1.HttpServlet中为什么要根据请求方式的不同，调用不同方法？get和post的请求方式的请求消息不同，所以要分别处理；2.如何调用？获取请求方式，进行不同判断1.HttpServlet使用步骤①继承HttpServlet②重写doGet和doPost方法2.HttpServlet)原理获取请求方式，并根据不同的请求方式，调用不同的doXxx方法Servlet urlPattern配置Servlet要想被访问，必须配置其访问路径(urlPattern)1.一个Servlet,可以配置多个urlPattern@WebServlet(urlPatterns {“/demo1”,”/demo2”})2.urlPattern配置规则①精确匹配urlPatterns = “/user/select”②目录匹配urlPatterns = “/user/*”③扩展名匹配urlPatterns = “*.do”④任意匹配urlPatterns = “/“urlPatterns = “/*”/和/*区别：当我们的项目中的Servleti配置了”/”，会覆盖掉tomcat中的DefaultServlet,当其他的url-pattern都匹配不上时都会走这个Servlet当我们的项目中配置了”/*”，意味若匹配任意访问路径优先级：精确路径&gt;目录路径&gt;扩展名路径&gt;/*&gt;/XML配置方式编写ServletServlet从3.0版本后开始支持使用注解配置，3.0版本前只支持XML配置文件的配置方式步骤：编写Servlet类在web.xml中配置该ServletRequest    Response请求 RequestRequest继承体系ServletRequestJava提供的请求对象根接口HttpServletRequestJava提供的对Http协议封装的请求对象接口RequestFacadeTomcat定义的实现类Tomcat需要解析请求数据，封装为request对象，并且创建request对象传递到service方法中使用request对象，查阅)avaEE API文档的HttpServletRequest接口Request获取请求数据获取请求数据请求行String getMethod():获取请求方式：GETString getContextPath(:获取虚拟目录（项目访问路径）：/request-.demoStringBuffer getRequestURL0:获取URL(统一资源定位符)：http://localhost::8080/request-demo/req1String getRequestURI():获取URI(统一资源标识符)：/request-demo/req1String getQueryString():获取请求参数(GET方式)：username:=zhangsan&amp;password=123请求头String getHeader(String name):根据请求头名称，获取值请求体·ServletInputStream getlnputStream0:获取字节输入流BufferedReader getReader():获取字符输入流通用方式获取请求参数请求参数获取方式：GET方式：String getQueryString()POST方式BufferedReader getReader()Map&lt;String,String[]&gt;getParameterMap():获取所有参数Map集合String[]getParameterValues(String name):根据名称获取参数值（数组）String getParameter(String name):根据名称获取参数值（单个值）请求参数中文乱码处理解决方案：POST:设置输入流的编码req.setCharacterEncoding(“UTF-8”):GET:设置输入流的编码username = new String(username.getBytes(StandardCharsets.ISO_8859_1), StandardCharsets.UTF_8);URL编码1.将字符串按照编码方式转为二进制2.每个字节转为2个16进制数并在前边加上%Tomcat8.0之后，已将GET请求乱码问题解决，设置默认的解码方式为UTF-81.中文乱码解决方案：POST:设置输入流的编码reqsetCharacterEncoding(“UTF-8”);通用方式(GET/POST)：先解码，再编码new String(username.getBytes(“ISO-8859-1”),”UTF-8”);2.URL编码实现方式：编码：URLEncoder.encode(str,”utf-8”):解码：URLDecoder.decode(s,”ISO-8859-1”);Request请求转发请求转发(forward):一种在服务器内部的资源跳转方式实现方式：req.getRequestDispatcher(“资源B路径”).forward(req,resp);请求转发资源间共享数据：使用Request对象void setAttribute(String name,Object o):存储数据到request域中Object getAttribute(String name):根据key,获取值void removeAttribute(String name):根据key,删除该键值对请求转发特点：浏览器地址栏路径不发生变化只能转发到当前服务器的内部资源一次请求，可以在转发的资源间使用request共享数据响应 Response- Response设置响应数据功能介绍响应数据分为3部分：1.响应行：void setStatus(int sc):设置响应状态码2.响应头：·void setHeader(String name,String value):设置响应头键值对3.响应体：·PrintWriter getWriter():获取字符输出流ServletOutputStream getOutputStream():获取字节输出流Response完成重定向重定向(Redirect):一种资源跳转方式实现方式：resp.setStatus(302);resp.setHeader(“location,“资源B的路径”);        - resp.sendRedirect(资源B的路径”)：- 重定向特点：    - 浏览器地址栏路径发生变化    - 可以重定向到任意位置的资源（服务器内部、外部均可）    - 两次请求，不能在多个资源使用request共享数据资源路径问题明确路径谁使用？浏览器使用：需要加虚拟目录项目访问路径)服务端使用：不需要加虚拟目录Response响应字符数据使用：1,通过Response对象获取字符输出流PrintWriter writer resp.getWriter();2.写数据writer.write(“aaa”);注意：该流不需要关闭，随着响应结束，response对象销毁，由服务器关闭中文数据乱码：原因通过Response获取的字符输出流默认编码：ISO-8859-1resp.setContentType(“text/html;charset=utf-8”);Response响应字节数据使用：1.通过Response对象获取字符输出流ServletOutputStream outputStream resp.getOutputStream();2.写数据outputStream.write(字节数据);1 DUtils工具类使用1.导入坐标2.使用IOUtils.copy(输入流，输出流)：代码优化创建SqlSessionFactory代码优化问题：1,代码重复：工具类2.SqlSessionFactory工厂只创建一次，不要重复创建：静态代码块JSP    Cookie  Session动态网页开发技术 JspJSP·概念：Java Server Pages,Java服务端页面一种动态的网页技术，其中既可以定义HTML、JS、CSS等静态内容，还可以定义Java代码的动态内容JSP=HTML+JavaJSP的作用：简化开发，避免了在Servlete中直接输出HTML标签JSP快速入门1.导入JSP坐标2.创建SP文件3.编写HTML标签和Java代码JSP原理概念：Java Server Pages,Java服务端顷面JSP=HTML+Java,用于简化开发的JSP本质上就是个ServletJSP在被访问时，由JSP容器(Tomcat)将其转换为Java文件(Servlet),在由JSP容器Tomcat，将其编译，最终对外提供服务的其实就是这个字节码文件JSP脚本JSP脚本用于在JSP页面内定义Java代码JSP脚本分类：1.&lt;%..%&gt;:内容会直接放到_jspService()方法之中2.&lt;%=…%&gt;:内容会放到out.print()中，作为out.print()的参数3.&lt;%!…%&gt;:内容会放到_jspService()方法之外，被类直接包含JSP缺点·由于JSP页面内，既可以定义HTML标签，又可以定义Java代码，造成了以下问题：1,书写麻烦：特别是复杂的页面2.阅读麻烦3.复杂度高：运行需要依赖于各种环境，JRE,JSP容器，JavaEE…4.占内存和磁盘：JSP会自动生成，java和.class.文件占磁盘，运行的是.class.文件占内存5.调试困难：出错后，需要找到自动生成的java文件进行调试6.不利于团队协作：前端人员不会Java,后端人员不精HTMLEL表达式EL表达式语言，用于简化JSP页面内的Java代码主要功能：获取数据语法：${expression}$(brands)获取域中存储的key为brands的数据●JavaWeb中的四大域对象：1.page:当前页面有效2.request:当前请求有效3.session：当前会话有效4.application:当前应用有效EL表达式获取数据，会依次从这4个域中寻找，直到找到为止JSTL标签JSP标准标签库,使用标签取代JSP页面上的，Java代码if&lt;c:if test=”true”&gt;foritems:被遍历的容器var:遍历产生的临时变量varStatus:遍历状态对象begin:开始数end:结束数step:步长MVC模式和三层架构MVC模式MVC是一种分层开发的模式，其中：M:Model,业务模型，处理业务V:View,视图，界面展示C:Controller,控制器，处理请求，调用模型和视图MVC好处职责单一，互不影响有利于分工协作有利于组件重用三层架构数据访问层：对数据库的CRUD基本操作业务逻辑层：对业务逻辑进行封装，组合数据访问层层中基本功能，形成复杂的业务逻辑功能表现层：接收请求，封装数据，调用业务逻辑层，响应数据高表现层com.itheima.web/controller业务逻辑层com.itheima.service数据访问层com.itheima.dao/mapper三层框架表现层SpringMVCStruts2业务逻辑层Spring数据访问层MyBatisHibername会话跟踪技术 Cookie Session概念会话：用户打开浏览器，访问web服务器的资源，会话建立，直到有一方断开连接，会话结束。在一次会话中可以包含多次请求和响应会话跟踪：一种维护浏览器状态的方法，服务器需要识别多次请求是否来自于同一浏览器，以便在同一次会话的多次请求间共享数据HTTP协议是无状态的，每次浏览器向服务器请求时，服务器都会将该请求视为新的请求，因此我们需要会话跟踪技术来实现会话内数据共享客户端会话跟踪技术：CookieCookie基本使用Cookie:：客户端会话技术，将数据保存到客户端，以后每次请求都携带Cookie数据进行访问发送Cookie1.创建Cookie对象，设置数据Cookie cookie = new Cookie(“key”,”value”);2.发送Cookie到客户端：使用response.对象response.addCookie(cookie);获取Cookie3.获取客户端携带的所有Cookie,使用requesti对象Cookie[] cookies = request.getCookies();4.遍历数组，获取每一个Cookie对象：for5.使用Cookie对象方法获取数据cookie.getName();cookie.getValue();Cookie原理Cookiel的实现是基于HTTP协议的响应头：set-cookie请求头：cookieCookie使用细节Cookie存活时间默认情况下，Cookie存储在浏览器内存中，当浏览器关闭，内存释放，则Cookie被销毁setMaxAge(int seconds):设置Cookie存活时间1.正数：将Cookie写入浏览器所在电脑的硬盘，持久化存储。到时间自动删除2.负数：默认值，Cookie在当前浏览器内存中，当浏览器关闭，则Cookie被销毁3.零：删除对应CookieCookie存储中文Cookie不能直接存储中文如需要存储，则需要进行转码：URL编码服务端会话跟踪技术：SessionSession基本使用服务端会话跟踪技术：将数据保存到服务端JavaEE提供HttpSession接口，来实现一次会话的多次请求间数据共享功能使用：1.获取Session对象HttpSession session request.getSession();2.Session对象功能：void setAttribute(String name,Object o):存储数据到session域中Object getAttribute(String name):根据key,获取值void removeAttribute(String name)):根据key,制除该键值对Session原理Session是基于Cookie实现的Session使用细节Session钝化、活化：服务器重启后，Session中的数据是香否还在？钝化：在服务器正常关闭后，Tomcats会自动将Session数据写入硬盘的文件中活化：再次启动服务器后，从文件中加载数据到Session中Seesion销毁：默认情况下，无操作，30分钟自动销毁调用Session对象的invalidate()方法总结Cookie和Session都是来完成一次会话内多次请求间数据共享的区别：存储位置：Cookie是将数据存储在客户端，Session将数据存储在服务端安全性：Cookie不安全，Session安全数据大小：Cookie最大3KB,Session无大小限制●存储时间：Cookie可以长期存储，Session默认30分钟●服务器性能：Cookie不占服务器资源，Session占用服务器资源会话技术.pdfFilter   Listener   Ajax过滤器   Filter概念Filter表示过滤器，是JavaWeb三大组件(Servlet,Filter、Listener)之一。过滤器可以把对资源的请求拦截下来，从而实现一些特殊的功能。过滤器一般完成一些通用的操作，比如：权限控制、统一编码处理、敏感字符处理等等…Filter 快速入门开发步骤进行 Filter 开发分成以下三步实现定义类，实现 Filter接口，并重写其所有方法配置Filter拦截资源的路径：在类上定义 @WebFilter 注解。而注解的 value 属性值 /* 表示拦截所有的资源在doFilter方法中输出一句话，并放行Filter 执行流程  - 放行后访问对应资源，资源访问完成后，还会回到Filter中访问完资源后，会回到 放行后逻辑，执行该部分代码。Filter 使用细节Filter 拦截路径配置拦截路径表示 Filter 会对请求的哪些资源进行拦截，使用 @WebFilter 注解进行配置。如：@WebFilter(“拦截路径”)拦截路径有如下四种配置方式：拦截具体的资源：/index.jsp：只有访问index.jsp时才会被拦截目录拦截：/user/*：访问/user下的所有资源，都会被拦截后缀名拦截：*.jsp：访问后缀名为jsp的资源，都会被拦截拦截所有：/*：访问所有资源，都会被拦截过滤器链过滤器链是指在一个Web应用，可以配置多个过滤器，这多个过滤器称为过滤器链。我们现在使用的是注解配置Filter，而这种配置方式的优先级是按照过滤器类名(字符串)的自然排序。比如有如下两个名称的过滤器 ： BFilterDemo 和 AFilterDemo 。那一定是 AFilterDemo 过滤器先执行。案例监听器  Listener概念Listener 表示监听器，是 JavaWeb 三大组件(Servlet、Filter、Listener)之一。监听器可以监听就是在application,session,.request三个对象创建、销毁或者往其中添加修改删除，属性时自动执行代码的功能组件Listener分类：JavaWeb中提供了8个监听器启动服务器，就可以在启动的日志信息中看到 contextInitialized() 方法输出的内容，同时也说明了 ServletContext对象在服务器启动的时候被创建了。异步交互技术 Ajax概念AJAX (Asynchronous JavaScript And XML)：异步的 JavaScript 和 XML。作用与服务器进行数据交换：通过AJAX可以给服务器发送请求，服务器将数据直接响应回给浏览器。使用AJAX和服务器进行通信，以达到使用 HTML+AJAX来替换JSP页面异步交互：可以在不重新加载整个页面的情况下，与服务器交换数据并更新部分网页的技术，如：搜索联想、用户名是否可用校验，等等…同步和异步同步浏览器页面在发送请求给服务器，在服务器处理请求的过程中，浏览器页面不能做其他的操作。只能等到服务器响应结束后才能，浏览器页面才能继续做其他的操作。异步浏览器页面发送请求给服务器，在服务器处理请求的过程中，浏览器页面还可以做其他的操作。AJAX快速入门1.编写AjaxServlet,并使用response输出字符串2.创建XMLHttpRequest对象：用于和服务器交换数据3.向服务器发送请求4.获取服务器响应数据Axios异步框架概念Axios 对原生的AJAX进行封装，简化书写。Axios快速入门引入 axios 的 js 文件使用axios 发送请求，并获取响应结果Axios请求方式别名为了方便起见， Axios 已经为所有支持的请求方法提供了别名。如下：get 请求 ： axios.get(url[,config])delete 请求 ： axios.delete(url[,config])head 请求 ： axios.head(url[,config])options 请求 ： axios.option(url[,config])post 请求： axios.post(url[,data[,config])put 请求： axios.put(url[,data[,config])patch 请求： axios.patch(url[,data[,config])JSONJSON基础语法定义格式SON 本质就是一个字符串，但是该字符串内容是有一定的格式要求的JSON 串的键要求必须使用双引号括起来，而值根据要表示的类型确定。注意js 提供的 JSON 对象我们只需要了解一下即可。因为 axios 会自动对 js 对象和 JSON 串进行想换转换。发送异步请求时，如果请求参数是 JSON 格式，那请求方式必须是 POST 。因为 JSON 串需要放在请求体中。概念JavaScript Object Notation 。JavaScript 对象表示法作用：由于其语法格式简单，层次结构鲜明，现多用于作为数据载体，在网络中进行数据传输。JSON数据和Java对象转换概念请求数据：JSON字符串转为ava对象响应数据：Java对象转为SON字符串Fastjson 是阿里巴巴提供的一个Java语言编写的高性能功能完善的 JSON 库，是目前Java语言中最快的 JSON 库，可以实现 Java 对象和 JSON 字符串的相互转换。Filter&amp;Listener&amp;Ajax.pdfVue  ElementUI前端开发框架   Vue概念Vue是一套前端框架，免除原生JavaScript中的DOM操作，简化书写基于MVVM(Model–View-ViewModel)思想，实现数据的双向绑定，将编程的关注点放在数据上MVC 和 MVVMMVC：只能实现模型到视图的单向展示MVVM:可以实现数据的双向绑定Vue快速入门1.新建HTML页面，引l入Vue.js文件2.在S代码区域，创建Vue核心对象，进行数据绑定3.编写视图Vue常用指令指令：HTML标签上带有V-前缀的特殊属性，不同指令具有不同含义。例如：V-if,V-for..常用指令v-bind为HTML标签绑定属性值，如设置href,css样式等v-model在表单元素上创建双向数据绑定v-on为HTML标签绑定事件v-ifv-else条件性的渲染某元素，判定为true时渲染，否则不渲染v-else-ifv-show根据条件展示某元素，区别在于切换的是display属性的值v-for列表渲染，遍历容器的元素或者对象的属性Vue生命周期生命周期的八个阶段：每触发一个生命周期事件，会自动执行一个生命周期方法（钩子）mounted:挂载完成，Vue初始化成功，HTML页面渲染成功发送异步请求，加载数据[网站组件库   Element](file://H:\网站\Element - 网站快速成型工具.url)概念Element:是饿了么公司前端开发团队提供的一套基于Vue的网站组件库，用于快速构建网页组件：组成网页的部件，例如超链接、按钮、图片、表格等等~Element快速入门1.引入Element的css、js文件和Vue.js2.创建Vue核心对象3.官网复制Element组件代码Element布局Element中有两种布局方式：Layout布局：通过基础的24分栏，迅速简便地创建布局Container布局容器：用于布局的容器组件，方便快速搭建页面的基本结构Element组件Thymeleaf</select></li></ol></li></ul></li></ul></li></ul></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 作者：赵燕军 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2023/07/14/hello-world/"/>
      <url>/2023/07/14/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
